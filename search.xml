<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++标准模板库(STL)</title>
      <link href="/2019/11/16/day03/"/>
      <url>/2019/11/16/day03/</url>
      
        <content type="html"><![CDATA[<h2 id="C-标准模板块-STL-介绍"><a href="#C-标准模板块-STL-介绍" class="headerlink" title="C++标准模板块(STL)介绍"></a>C++标准模板块(STL)介绍</h2><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><h3 id="1-set-的定义"><a href="#1-set-的定义" class="headerlink" title="1. set 的定义"></a>1. set 的定义</h3><h4 id="emsp-emsp-单独定义一个set"><a href="#emsp-emsp-单独定义一个set" class="headerlink" title="&emsp;&emsp;单独定义一个set"></a>&emsp;&emsp;单独定义一个set</h4><pre><code>set&lt;typename&gt; name;set&lt;double&gt; name;set&lt;int&gt; name;set&lt;char&gt; name;set&lt;node&gt; name;    // node 是结构体的类型</code></pre><h4 id="emsp-emsp-set数组的定义和-vector-相同"><a href="#emsp-emsp-set数组的定义和-vector-相同" class="headerlink" title="&emsp;&emsp;set数组的定义和 vector 相同"></a>&emsp;&emsp;set数组的定义和 vector 相同</h4><pre><code>set&lt;typename&gt; st[100];</code></pre><p>&emsp;&emsp;这样 st[0] - st[99] 中每一个都是一个vector容器。</p><h3 id="2-set-容器内元素的访问"><a href="#2-set-容器内元素的访问" class="headerlink" title="2. set 容器内元素的访问"></a>2. set 容器内元素的访问</h3><h4 id="emsp-emsp-set-只能通过迭代器-iterator-访问"><a href="#emsp-emsp-set-只能通过迭代器-iterator-访问" class="headerlink" title="&emsp;&emsp;set 只能通过迭代器(iterator)访问"></a>&emsp;&emsp;set 只能通过迭代器(iterator)访问</h4><pre><code>set&lt;typename&gt;::iterator it;</code></pre><p>&emsp;&emsp;typename 就是定义 set 时填写的类型，下面是 typename 为 int 和 char 的举例：</p><pre><code>set&lt;int&gt;::iterator it;set&lt;char&gt;::iterator it;</code></pre><p>&emsp;&emsp;这样就得到了迭代器it，并且可以通过 *it 来访问 set 里的元素。</p><p>&emsp;&emsp;由于<strong>除开 vector 和 string 之外的 STL 容器都不支持 *(it + i)</strong>的访问方式，因此只能按照以下方式枚举：</p><pre><code>#include&lt;iostream&gt;#include&lt;set&gt;using namespace std;int main() {    set&lt;int&gt; st;    st.insert(3);    // insert(x)将 x 插入 set 中    st.insert(5);    st.insert(2);    st.insert(3);     // 注意，不支持 it &lt; st.end() 的写法    for(set&lt;int&gt;::iterator it = st.begin(); it != st.end(); it++) {        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    }    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>2 3 5</code></pre><h3 id="3-set-常用的函数实例解析"><a href="#3-set-常用的函数实例解析" class="headerlink" title="3. set 常用的函数实例解析"></a>3. set 常用的函数实例解析</h3><h4 id="1-insert"><a href="#1-insert" class="headerlink" title="(1) insert()"></a>(1) insert()</h4><p>&emsp;&emsp;insert(x) 可将 x 插入 set 容器中，并自动递增排序和去重，时间复杂度为 O(logN)，其中 N 为 set 内的元素的个数。</p><h4 id="2-find"><a href="#2-find" class="headerlink" title="(2) find()"></a>(2) find()</h4><p>&emsp;&emsp;find(value) 返回 set 中对应值为 value 的迭代器，时间复杂度为 O(logN)，其中 N 为 set 内的元素的个数。</p><pre><code>#include&lt;iostream&gt;#include&lt;set&gt;using namespace std;int main() {    set&lt;int&gt; st;    for(int i = 1; i &lt;= 3; i++) {        st.insert(i);    }    set&lt;int&gt;::iterator it = st.find(2);    //在 set 中查找2，返回其迭代器    cout &lt;&lt; *it;    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>2</code></pre><h4 id="3-erase"><a href="#3-erase" class="headerlink" title="(3) erase()"></a>(3) erase()</h4><p>&emsp;&emsp;erase()有两种方法：删除单个元素，删除一个区间内的所有元素。</p><p>&emsp;&emsp;① 删除单个元素。</p><p>&emsp;&emsp;删除单个元素的方法：</p><ul><li><p>st.erase(it)，it 为所有需要删除元素的迭代器。时间复杂度为 O(1)。可以结合 find()  函数来使用。示例如下：</p><pre><code>  #include&lt;iostream&gt;  #include&lt;set&gt;  using namespace std;  int main() {      set&lt;int&gt; st;      st.insert(100);      st.insert(200);      st.insert(100);      st.insert(300);          st.erase(st.find(100));    // 利用 find()函数找到100， 然后用 erase 删除它      st.erase(st.find(200));    // 利用 find()函数找到100， 然后用 erase 删除它      for(set&lt;int&gt;::iterator it = st.begin(); it != st.end(); it++) {          cout &lt;&lt; *it;      }      return 0;  }</code></pre></li></ul><p>&emsp;&emsp;输出结果：</p><pre><code>200</code></pre><p>&emsp;&emsp;② 删除一个区间内的所有元素。<br>&emsp;&emsp;st.erase(first, end)可以删除一个区间内的所有元素，其中 first 为所需要删除区间的起始迭代器，而 last 则为所需要删除区间的末尾迭代器的下一个地址，也即为删除[first, last)。时间复杂度为 O(last - first)。示例如下：</p><pre><code>#include&lt;iostream&gt;#include&lt;set&gt;using namespace std;int main() {    set&lt;int&gt; st;    st.insert(20);    st.insert(10);    st.insert(40);    st.insert(30);        set&lt;int&gt;::iterator it  = st.find(30);    st.erase(it, st.end()); // 删除元素 30 至 set 末尾之间的元素，即 30 和 40                for(set&lt;int&gt;::iterator it = st.begin(); it != st.end(); it++) {        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    }    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>3</code></pre><h4 id="4-size"><a href="#4-size" class="headerlink" title="(4) size()"></a>(4) size()</h4><p>&emsp;&emsp;size() 用来获取 set 内元素的个数，时间复杂度为 O(1)。</p><p>&emsp;&emsp;示例如下：</p><pre><code>#include&lt;iostream&gt;#include&lt;set&gt;using namespace std;int main() {    set&lt;int&gt; st;    st.insert(2);    st.insert(5);    st.insert(4);    // 插入 2 5 4    st.clear();        // 输出 set 内元素的个数    cout &lt;&lt; st.size();            return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>3</code></pre><h4 id="5-clear"><a href="#5-clear" class="headerlink" title="(5) clear()"></a>(5) clear()</h4><p>&emsp;&emsp;clear() 用来清空 set 中的所有元素，复杂度为 O(N)，其中 N 为 set 内元素的个数。</p><p>&emsp;&emsp;示例如下：</p><pre><code>#include&lt;iostream&gt;#include&lt;set&gt;using namespace std;int main() {    set&lt;int&gt; st;    st.insert(2);    st.insert(5);    st.insert(4);    st.clear();    // 清空 set    cout &lt;&lt; st.size();            return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>0</code></pre><h3 id="3-set-的常见用途"><a href="#3-set-的常见用途" class="headerlink" title="3. set 的常见用途"></a>3. set 的常见用途</h3><h4 id="emsp-emsp-set-最主要的作用是自动去重并按升序排序，因此碰到需要去重但是却不方便直接开数组的情况，可以尝试用-set-解决。"><a href="#emsp-emsp-set-最主要的作用是自动去重并按升序排序，因此碰到需要去重但是却不方便直接开数组的情况，可以尝试用-set-解决。" class="headerlink" title="&emsp;&emsp;set 最主要的作用是自动去重并按升序排序，因此碰到需要去重但是却不方便直接开数组的情况，可以尝试用 set 解决。"></a>&emsp;&emsp;set 最主要的作用是自动去重并按升序排序，因此碰到需要去重但是却不方便直接开数组的情况，可以尝试用 set 解决。</h4><p>&emsp;&emsp;<strong>延伸</strong>：set 中元素是唯一的，如果需要处理不唯一的情况，则需要使用 <strong>multiset</strong>。</p><p>&emsp;&emsp; 晚安。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> Markdown </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++标准模板库(STL)</title>
      <link href="/2019/11/16/day02/"/>
      <url>/2019/11/16/day02/</url>
      
        <content type="html"><![CDATA[<h2 id="C-标准模板块-STL-介绍"><a href="#C-标准模板块-STL-介绍" class="headerlink" title="C++标准模板块(STL)介绍"></a>C++标准模板块(STL)介绍</h2><h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><h3 id="1-vector-的定义"><a href="#1-vector-的定义" class="headerlink" title="1. vector 的定义"></a>1. vector 的定义</h3><h4 id="emsp-emsp-单独定义一个vector"><a href="#emsp-emsp-单独定义一个vector" class="headerlink" title="&emsp;&emsp;单独定义一个vector"></a>&emsp;&emsp;单独定义一个vector</h4><pre><code>vector&lt;int&gt; name;vector&lt;double&gt; name;vector&lt;char&gt; name;vector&lt;node&gt; name;    // node是结构体类型vector&lt;vector&lt;typename&gt; &gt; name;    // &gt;&gt; 之间要有空格</code></pre><h4 id="emsp-emsp-定义vector数组的方法"><a href="#emsp-emsp-定义vector数组的方法" class="headerlink" title="&emsp;&emsp;定义vector数组的方法"></a>&emsp;&emsp;定义vector数组的方法</h4><pre><code>vector&lt;int&gt; vi[100];</code></pre><p>&emsp;&emsp;这样vi[0] - vi[99] 中每一个都是一个vector容器。</p><h3 id="2-vector-容器内元素的访问"><a href="#2-vector-容器内元素的访问" class="headerlink" title="2. vector 容器内元素的访问"></a>2. vector 容器内元素的访问</h3><p>&emsp;&emsp;vector 一般有两种访问方式：通过下标访问或通过迭代器访问。</p><h4 id="通过下标访问"><a href="#通过下标访问" class="headerlink" title="通过下标访问"></a>通过下标访问</h4><p>&emsp;&emsp;和访问普通的数组是一样的，对一个定义为 vector<typename> vi 的vector容器来说，直接访问 vi[index] 即可（如vi[0],vi[1]）。当然，这里下标是从 0 到 vi.size() - 1，访问这个范围以外的元素可能会运行报错。</p><h4 id="通过迭代器访问"><a href="#通过迭代器访问" class="headerlink" title="通过迭代器访问"></a>通过迭代器访问</h4><p>&emsp;&emsp;迭代器(itreator)可以理解为一种类似指针的东西，其定义是：</p><pre><code>vector&lt;typename&gt;::iterator it;</code></pre><p>&emsp;&emsp;这样 it 就是一个 vector<typename>::iterator 类型的变量（虽然这个变量看起来很长），其中 typename 就是定义 vector 时填写的类型。下面是 typename 为 int 和 double的举例：</p><pre><code>vector&lt;int&gt;::iterator it;vector&lt;double&gt;::iterator it;</code></pre><p>&emsp;&emsp;这样就得到了迭代器 it，并且可以通过 *it 来访问 vector 里的元素。<br>例如，有这样定义的一个 vector 容器：</p><pre><code>vector&lt;int&gt; vi;for(int i = 0; i &lt;= 5; i++) {    vi.push_back(i);    // push_back(i)在vi的末尾添加元素i，即依次添加 1 2 3 4 5}</code></pre><p>&emsp;&emsp;可以通过类似下标和指针访问数组的方式来访问容器内的元素：</p><pre><code>#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main() {    vector&lt;int&gt; vi;    for(int i = 1; i &lt;= 5; i++) {        vi.push_back(i);    }    // vi.begin()为取 vi 的首元素地址，而 it 指向这个地址    vector&lt;int&gt;::iterator it = vi.begin();    for(int i = 0; i &lt; 5; i++) {        cout &lt;&lt; *(it + i) &lt;&lt; &quot; &quot;;        }    return 0;}</code></pre><p>&emsp;&emsp;输出结果</p><pre><code>1 2 3 4 5</code></pre><p>&emsp;&emsp;从这里可以看出 <strong>v[i] 和 *(vi.begin() + i) 是等价的</strong>。<br>既然上面说到了begin()函数的作用为取 vi 的首地址元素，那么这里还要提到 end()函数。和begin()函数不同的是，end() 并不是取 vi 的尾元素地址，而是取尾元素地址的下一个地址。end()作为迭代器末尾标志，不存储任何元素。美国人思维比较<strong>左闭右开</strong>，在这里begin() 和 end()也是如此。</p><p>&emsp;&emsp;除此之外，迭代器还实现了两种自加操作：++it 和 it++（自减操作同理），于是有了另一中遍历 vector 中元素的写法：</p><pre><code>#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main() {    vector&lt;int&gt; vi;    for(int i = 1; i &lt;= 5; i++) {        vi.push_back(i);    }    // vector 的迭代器不支持 it &lt; vi.end() 写法，因此循环条件只能用 it != vi.end()    for(vector&lt;int&gt;::iterator it = vi.begin(); it != vi.end(); it++) {        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;        }    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>1 2 3 4 5</code></pre><p>&emsp;&emsp;最后需要指出，在常用的 <strong>STL</strong> 容器中，只有在 <strong>vector</strong> 和 <strong>string</strong> 中，才允许使用 <strong>vi.begin() + 3 这种迭代器加上整数的写法</strong>。</p><h3 id="3-vector-常用函数实例解析"><a href="#3-vector-常用函数实例解析" class="headerlink" title="3. vector 常用函数实例解析"></a>3. vector 常用函数实例解析</h3><h4 id="1-push-back"><a href="#1-push-back" class="headerlink" title="(1) push_back()"></a>(1) push_back()</h4><p>&emsp;&emsp;顾名思义，push_back(x)就是在 vector 后面添加一个元素 x，时间复杂度为O(1)。</p><p>&emsp;&emsp;示例如下：</p><pre><code>#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main() {    vector&lt;int&gt; vi;    for(int i = 1; i &lt;= 3; i++) {        vi.push_back(i);    // 将 1 2 3 依次插入 vi 末尾    }    for(int i =0; i &lt; vi.size(); i++) {    // size() 函数会给出 vi 中元素的个数        cout &lt;&lt; vi[i] &lt;&lt; &quot; &quot;;        }    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>1 2 3</code></pre><h4 id="2-pop-back"><a href="#2-pop-back" class="headerlink" title="(2) pop_back()"></a>(2) pop_back()</h4><p>&emsp;&emsp;有添加就会有删除，pop_back()用以删除 vector 的尾元素，时间复杂度为 O(1)。</p><p>&emsp;&emsp;示例如下：</p><pre><code>#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main() {    vector&lt;int&gt; vi;    for(int i = 1; i &lt;= 3; i++) {        vi.push_back(i);    // 将 1 2 3 依次插入 vi 末尾    }    vi.pop_back();    // 删除 vi 的尾元素    for(vector&lt;int&gt;::iterator it = vi.begin(); it != vi.end(); it++) {    // size() 函数会给出 vi 中元素的个数        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;        }    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>1 2</code></pre><h4 id="3-size"><a href="#3-size" class="headerlink" title="(3) size()"></a>(3) size()</h4><p>&emsp;&emsp;size()用来获得 vector 中元素的个数，时间复杂度为O(1)。size()返回的是 unsigned 类型，不过一半来说用 %d 不会出现太大问题，这一点对所有 <strong>STL</strong> 容器都是一样的。</p><p>&emsp;&emsp;示例如下：</p><pre><code>#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main() {    vector&lt;int&gt; vi;    for(int i = 1; i &lt;= 3; i++) {        vi.push_back(i);    // 将 1 2 3 依次插入 vi 末尾    }    cout &lt;&lt; vi.size();    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>3</code></pre><h4 id="4-clear"><a href="#4-clear" class="headerlink" title="(4) clear()"></a>(4) clear()</h4><p>&emsp;&emsp;clear() 用来清空 vector 中的所有元素，时间复杂度为 O(N)，其中 N 为 vector 中元素的个数。</p><p>&emsp;&emsp;示例如下：</p><pre><code>#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main() {    vector&lt;int&gt; vi;    for(int i = 1; i &lt;= 3; i++) {        vi.push_back(i);    // 将 1 2 3 依次插入 vi 末尾    }    vi.clear();    cout &lt;&lt; vi.size();    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>0</code></pre><h4 id="5-insert"><a href="#5-insert" class="headerlink" title="(5) insert()"></a>(5) insert()</h4><p>&emsp;&emsp;insert(it, x) 用来向 vector 的任意迭代器 it 处插入一个元素 x，时间复杂度为 O(N)。</p><p>&emsp;&emsp;示例如下：</p><pre><code>#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main() {    vector&lt;int&gt; vi;    for(int i = 1; i &lt;= 5; i++) {        vi.push_back(i);    // 此时为 1 2 3 4 5    }    vi.insert(vi.begin() + 2, -1); // 将 -1 插入 vi[2] 的位置    for(vector&lt;int&gt;::iterator it; it != vi.end(); it++) {        cout &lt;&lt; it &lt;&lt; &quot; &quot;;    }    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>1 2 -1 3 4 5</code></pre><h4 id="6-erase"><a href="#6-erase" class="headerlink" title="(6) erase()"></a>(6) erase()</h4><p>&emsp;&emsp;erase() 有两种方法：删除单个元素，删除一个区间内的所有元素。时间复杂符均为 O(n)。</p><p>&emsp;&emsp;① 删除单个元素。</p><p>&emsp;&emsp;erase(it) 即删除迭代器 it 处的元素。</p><p>&emsp;&emsp;示例如下：</p><pre><code>#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main() {    vector&lt;int&gt; vi;    for(int i = 5; i &lt;= 9; i++) {        vi.push_back(i);    // 插入 5 6 7 8 9    }    // 删除 8    vi.erase(vi.begin() + 3);    for(int i = 0; i &lt; vi.size(); i++) {        cout &lt;&lt; vi[i] &lt;&lt; &quot; &quot;;    }    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>5 6 7 9</code></pre><p>&emsp;&emsp;② 删除一个区间内的所有元素。</p><p>&emsp;&emsp;erase(first, last) 即删除[first, end)内所有的元素。</p><p>&emsp;&emsp;示例如下：</p><pre><code>#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main() {    vector&lt;int&gt; vi;    for(int i = 5; i &lt;= 9; i++) {        vi.push_back(i);    // 插入 5 6 7 8 9    }    vi.erase(vi.begin() + 1, vi.begin() + 4);    // 删除vi[1],vi[2],vi[3]    for(int i = 0; i &lt; vi.size(); i++) {        cout &lt;&lt; vi[i] &lt;&lt; &quot; &quot;;    }    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>5 9</code></pre><h3 id="vector-的常见用途"><a href="#vector-的常见用途" class="headerlink" title="vector 的常见用途"></a>vector 的常见用途</h3><h4 id="emsp-emsp-1-存储数据"><a href="#emsp-emsp-1-存储数据" class="headerlink" title="&emsp;&emsp;(1) 存储数据"></a>&emsp;&emsp;<strong>(1) 存储数据</strong></h4><p>&emsp;&emsp;① vector 本身可以作为数组使用，而且在一些元素个数不确定的场合可以很好地节省空间。</p><p>&emsp;&emsp;② 有些场合需要根据一些条件把部分数据输出在同一行，数据中间用空格隔开。由于输出数据的个数是不确定的，为了更方便地处理最后一个满足条件的数据后面，不输出额外的空格，可以先用 vector 记录所有需要输出的数据，然后一次性输出。</p><h4 id="emsp-emsp-2-用邻接表存储图"><a href="#emsp-emsp-2-用邻接表存储图" class="headerlink" title="&emsp;&emsp;(2) 用邻接表存储图"></a>&emsp;&emsp;<strong>(2) 用邻接表存储图</strong></h4><p>&emsp;&emsp;晚安。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> Markdown </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基础——对C的增强</title>
      <link href="/2019/11/15/day01/"/>
      <url>/2019/11/15/day01/</url>
      
        <content type="html"><![CDATA[<h2 id="C-基础—对C的增强"><a href="#C-基础—对C的增强" class="headerlink" title="C++基础—对C的增强"></a>C++基础—对C的增强</h2><p>我们都知道C++是完全兼容c的，而且对C做了一定的优化。</p><p>C++与C的不同在于：</p><h2 id="1-实用性的增强：变量可以任意定义了。"><a href="#1-实用性的增强：变量可以任意定义了。" class="headerlink" title="1.实用性的增强：变量可以任意定义了。"></a>1.实用性的增强：变量可以任意定义了。</h2><h3 id="在C中：变量的定义必须在函数使用之前，不然在早期的编译器中可能出错。"><a href="#在C中：变量的定义必须在函数使用之前，不然在早期的编译器中可能出错。" class="headerlink" title="在C中：变量的定义必须在函数使用之前，不然在早期的编译器中可能出错。"></a>在C中：变量的定义必须在函数使用之前，不然在早期的编译器中可能出错。</h3><pre><code>int i = 0;for(i = 0; i &lt; 10; i++) {    printf(&quot;Hello C&quot;);}</code></pre><h3 id="在C-中：变量可以任意定义，不过要注意变量的作用域和生存周期。"><a href="#在C-中：变量可以任意定义，不过要注意变量的作用域和生存周期。" class="headerlink" title="在C++中：变量可以任意定义，不过要注意变量的作用域和生存周期。"></a>在C++中：变量可以任意定义，不过要注意变量的作用域和生存周期。</h3><pre><code>for(int i = 0; i &lt; 10; i++) {    // 这里的i会随for循环的结束而被释放    cout &lt;&lt; &quot;Hello CPP&quot;;}</code></pre><h2 id="2-对全局检测能力的增强：不允许有重定义的现象出现。"><a href="#2-对全局检测能力的增强：不允许有重定义的现象出现。" class="headerlink" title="2.对全局检测能力的增强：不允许有重定义的现象出现。"></a>2.对全局检测能力的增强：不允许有重定义的现象出现。</h2><h3 id="在C-中：一个变量不管是声明还是定义只能出现一次。"><a href="#在C-中：一个变量不管是声明还是定义只能出现一次。" class="headerlink" title="在C++中：一个变量不管是声明还是定义只能出现一次。"></a>在C++中：一个变量不管是声明还是定义只能出现一次。</h3><pre><code>// int g_val;// int g_val = 10;// 这样定义在C中不回报错，但是在C++中会报错</code></pre><h2 id="3-对struct的增强。"><a href="#3-对struct的增强。" class="headerlink" title="3.对struct的增强。"></a>3.对struct的增强。</h2><pre><code>struct teacher {    int id;    char name[64];};void test() {    //在C语言中只能struct teacher t;这样定义除非加上typedef    //而在C++可以这样：    teacher t;}</code></pre><h2 id="4-对函数检测增强。"><a href="#4-对函数检测增强。" class="headerlink" title="4.对函数检测增强。"></a>4.对函数检测增强。</h2><h3 id="在C-中：对形参传递，返回值做了严格的检查，不允许任意传，任意调用，必须有返回值。"><a href="#在C-中：对形参传递，返回值做了严格的检查，不允许任意传，任意调用，必须有返回值。" class="headerlink" title="在C++中：对形参传递，返回值做了严格的检查，不允许任意传，任意调用，必须有返回值。"></a>在C++中：对形参传递，返回值做了严格的检查，不允许任意传，任意调用，必须有返回值。</h3><h3 id="在C中：可以任意，不过一般按照规范去写。"><a href="#在C中：可以任意，不过一般按照规范去写。" class="headerlink" title="在C中：可以任意，不过一般按照规范去写。"></a>在C中：可以任意，不过一般按照规范去写。</h3><pre><code>void f(int i) {    cout &lt;&lt; i &lt;&lt; endl; }void test3() {    f(1);    //在C中这样不会报错（warning），而在C++中这样会报错(error)。    //f(1, 2, 3);}</code></pre><h2 id="5-新增bool类型。"><a href="#5-新增bool类型。" class="headerlink" title="5.新增bool类型。"></a>5.新增bool类型。</h2><h3 id="在C语言中：非0代表真，0代表假。"><a href="#在C语言中：非0代表真，0代表假。" class="headerlink" title="在C语言中：非0代表真，0代表假。"></a>在C语言中：非0代表真，0代表假。</h3><pre><code>void test() {    int flag =1;//真    int flag=-1;//真    int flag=0;//假}</code></pre><h3 id="在C-中：新增了一个bool变量，bool变量的值只有0或1。"><a href="#在C-中：新增了一个bool变量，bool变量的值只有0或1。" class="headerlink" title="在C++中：新增了一个bool变量，bool变量的值只有0或1。"></a>在C++中：新增了一个bool变量，bool变量的值只有0或1。</h3><pre><code>void test() {    bool flag = true;    flag = false;//true--真，false--假    cout &lt;&lt; &quot;bool的size=&quot;&lt;&lt;sizeof(flag) &lt;&lt; endl;//1个字节    cout &lt;&lt; &quot;flag=&quot; &lt;&lt; flag &lt;&lt; endl;//为true值为1，为false值为0，不管为bool类型赋非0值则为1（true）,bool值只有0/1}</code></pre><h2 id="6-对三目运算符的增强。"><a href="#6-对三目运算符的增强。" class="headerlink" title="6.对三目运算符的增强。"></a>6.对三目运算符的增强。</h2><h3 id="在C中：a-gt-b-a-b-30一般会编译出错。原因是a-gt-b-a-b返回的是10，10-30会出错。"><a href="#在C中：a-gt-b-a-b-30一般会编译出错。原因是a-gt-b-a-b返回的是10，10-30会出错。" class="headerlink" title="在C中：a &gt; b ? a : b = 30一般会编译出错。原因是a &gt; b ? a : b返回的是10，10 = 30会出错。"></a>在C中：a &gt; b ? a : b = 30一般会编译出错。原因是a &gt; b ? a : b返回的是10，10 = 30会出错。</h3><h3 id="而在C-中：a-gt-b-a-b返回的是对b的引用。"><a href="#而在C-中：a-gt-b-a-b返回的是对b的引用。" class="headerlink" title="而在C++中：a &gt; b ? a : b返回的是对b的引用。"></a>而在C++中：a &gt; b ? a : b返回的是对b的引用。</h3><blockquote><p>注意：a &gt; b ? a : b作为左值时返回的结果不能有常量（常量不能取地址），做右值时任意。</p></blockquote><pre><code>void test(){    int a = 10;    int b = 20;    int max = 0;    max = a &gt; b ? a : b;    printf(&quot;%d\n&quot;,max);    //c：    //(a &gt; b ? a : b) = 30;    这样是错误的    *(a &gt; b ? &amp;a : &amp;b) = 30;    // 可以通过指针改变地址。    //c++:    (a &gt; b ? a : b) = 30;//在c中这个会出错20=30没有意义，在c++中可以使用a &gt; b ? a : b 返回b变量的引用        相当于：*(a&gt;b?&amp;a:&amp;b)=30    cout &lt;&lt; &quot;b=&quot; &lt;&lt; b &lt;&lt; endl;//30    //a &gt; b ? 10 : b = 30;//error,作为左值时返回的结果不能有常量（常量不能取地址），做右值时任意。}</code></pre><h2 id="7-const增强。"><a href="#7-const增强。" class="headerlink" title="7.const增强。"></a>7.const增强。</h2><h3 id="在C中："><a href="#在C中：" class="headerlink" title="在C中："></a>在C中：</h3><ol><li><p>const并不是一个常量，是一个变量加了只读属性。</p></li><li><p>const int 和 int const 是一样的。</p></li><li><p>const修饰的变量实际上是可以通过指针改变的，是一个假的常量。</p><pre><code> void test() {     const int a = 10;     int* p = &amp;a;     *p = 70;     printf(&quot;%d\n&quot;,a);    // 70 }</code></pre></li><li><p>与#define是有区别的。#define在预编译时处理，const在编译时处理。</p></li></ol><h3 id="const-int-c-int-const-c-和-const-int-count-的区别："><a href="#const-int-c-int-const-c-和-const-int-count-的区别：" class="headerlink" title="const int* c , int* const c 和 const int* count 的区别："></a>const int* c , int* const c 和 const int* count 的区别：</h3><ul><li>前者修饰const int表示指针C指向的地址的值不能改变，但是可以指向不同的地址。</li><li>中间修饰int 表示指针C不可以改变，但是指向的地址可以改变。</li><li>后者表示指针C不可以改变，指针指向的地址也不可以改变。</li></ul><h3 id="在c-中："><a href="#在c-中：" class="headerlink" title="在c++中："></a>在c++中：</h3><ol><li><p>const修饰表示的就是常量。const int a=1;这在C++中并不会在栈空间中开辟空间，而在内存中会有一个符号表去记录key—value。</p></li><li><p>a实际上是一个符号，是不能去访问地址的，但C++发现对一个const常量符号取地址时，会临时在栈上开辟一个临时空间，这个变量是匿名的，p–&gt;临时变量。</p></li></ol><h2 id="8-enum的增强。"><a href="#8-enum的增强。" class="headerlink" title="8.enum的增强。"></a>8.enum的增强。</h2><h3 id="C语言中枚举本质就是整型，枚举变量可以用任意整型赋值，而C-中枚举变量，只能用被枚举出来的元素初始化。"><a href="#C语言中枚举本质就是整型，枚举变量可以用任意整型赋值，而C-中枚举变量，只能用被枚举出来的元素初始化。" class="headerlink" title="C语言中枚举本质就是整型，枚举变量可以用任意整型赋值，而C++中枚举变量，只能用被枚举出来的元素初始化。"></a>C语言中枚举本质就是整型，枚举变量可以用任意整型赋值，而C++中枚举变量，只能用被枚举出来的元素初始化。</h3><pre><code>enum num {    a = 0,    b,    c,    d};void test() {    enum num n = a;    /*n = 0;    n = 1;    n = 2;    n = 3;*/    //在C语言中给枚举类型赋值时，可以通过枚举值赋值，而在C++中不可以}</code></pre><h2 id="9-引用的基本概念。"><a href="#9-引用的基本概念。" class="headerlink" title="9.引用的基本概念。"></a>9.引用的基本概念。</h2><ol><li>引用没有定义，是一种关系型声明。声明它和原有某一变量（实体）的关系。故而类型与原类型保持一致，且不分配内存。与被引用的变量有相同的内存地址。</li><li>声明的时候必须初始化，一经声明，不可变更。 </li><li>可对引用，再次引用。多次引用的结果，是某一变量具有多个别名。</li><li>&amp; 符号前有数据类型时，是引用，例如：int&amp;，double&amp;。其它皆为取地址。</li></ol><pre><code>#include&lt;iostream&gt;using namespace std;void change_value(int&amp; r) {    r = 30;}int main() {    int a = 20;    int b = 30;    int *p = &amp;a;    *p = 30;    cout &lt;&lt; a &lt;&lt; endl;    // 30    p = &amp;b;    *p = 20;    cout &lt;&lt; b &lt;&lt; endl;    // 20    int&amp; re = a;    // int&amp; 使用引用数据类型，re就是a的别名。     re = 50;    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;    // 50    // int&amp; re;    引用必须初始化。    int&amp; re2 = re;    // 可对引用，再次引用。    re2 = 60;    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;    cout &lt;&lt; &quot;-----------------&quot;&lt;&lt; endl;    change_value(a);    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;    return 0;}</code></pre><ol start="5"><li>通过引用 可以降低需要改变地址值时的难度。</li><li>引用作为函数的参数。</li></ol><pre><code>#include&lt;iostream&gt;using namespace std;struct student{    int id;    char name[64];};// 使用指针的方法 交换两个数的值 void swap(int* a, int* b) {    int temp;    temp = *a;    *a = *b;    *b = temp;}// 使用引用的方法 交换两个数的值 void swap2(int&amp; a, int&amp; b) {    int temp;    temp = a;    a = b;    b = temp;}// 使用普通的方法 void prints(student s) {    // 相当于 student s = s1; 变成了拷贝操作，不建议这样。     cout &lt;&lt; s.id &lt;&lt; &quot;\t&quot;&lt;&lt; s.name &lt;&lt; endl;}// 使用指针的方法 void prints2(student* s) {    // 相当于 student* s = &amp;s1;      cout &lt;&lt; s-&gt;id &lt;&lt; &quot;\t&quot;&lt;&lt; s-&gt;name &lt;&lt; endl;}// 使用引用的方法 void prints3(student&amp; s) {    // 相当于 student* s = &amp;s1;      cout &lt;&lt; s.id &lt;&lt; &quot;\t&quot;&lt;&lt; s.name &lt;&lt; endl;}int main() {    int a = 10, b = 20;//    swap(&amp;a, &amp;b);    swap2(a, b);    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;    cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;    student s1 = {10, &quot;zhangsan&quot;};    prints(s1);    prints2(s1);    prints3(s1);    return 0;} </code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>实用性增强（变量定义），全局变量定义检查（严格），变量类型检查严格，所有变量和函数定义必须有类型。</li><li>struct关键字（c中不是新类型），与class功能相同。</li><li>类型加强 bool 1个字节，但是只有 true 和 false。</li><li>C++中三目运算符，返回变量自身，C返回的是变量的值。</li><li>const增强<ul><li>指针变量和它所指向的内存空间变量是两个不同的概念。</li><li>C中冒牌货（只读变量有自己的存储空间）。</li><li>C++ const是一个只读常量，符号表机制，不可分配内存。</li><li>const是由编译器处理的，提供类型检查和作用域检查。</li><li>#define宏定义有预处理器处理，单纯的文本替换。</li></ul></li><li>引用<ul><li>引用没有定义，是一种关系型声明。声明它和原有某一变量（实体）的关系。故而类型与原类型保持一致，且不分配内存。与被引用的变量有相同的内存地址。</li><li>声明的时候必须初始化，一经声明，不可变更。 </li><li>可对引用，再次引用。多次引用的结果，是某一变量具有多个别名。</li><li>&amp; 符号前有数据类型时，是引用，例如：int&amp;，double&amp;。其它皆为取地址。</li><li>通过引用 可以降低需要改变地址值时的难度（好用）。</li><li>引用作为函数的参数。</li></ul></li></ol><p>&emsp;&emsp;晚安。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> Markdown </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客</title>
      <link href="/2019/11/13/wo-de-di-yi-pian-blog/"/>
      <url>/2019/11/13/wo-de-di-yi-pian-blog/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;<strong>忙碌了将近一天，终于把这个博客网站搭上了，哈哈哈，奈何自己太菜，只能用Hexo来写啦，搭这个博客的初衷很简单，就是想记录一下自己的经历吧。因为第一次搭博客，所以也遇见了一点小问题（具体的也忘记了。。。），不过什么也是自己琢磨出来的，总不能因为这点小小的问题就放弃把，失败就失败，大不了重来呗，我们还年轻，有的是机会重来。</strong></p><h3 id="我为什么要写博客？"><a href="#我为什么要写博客？" class="headerlink" title="我为什么要写博客？"></a><em>我为什么要写博客</em>？</h3><p>&emsp;&emsp;不管做什么事，总得知道做这件事的原因，做这件事的目的吧。</p><p>&emsp;&emsp;写博客对于我来说有什么或者将会带来什么好处，针对我个人而言，我认为写博客的最重要作用就是记录自己的成长足迹，因为它可以记录我各个阶段做了什么，收获了什么，不管是写技术博客，还是记录生活经历的博客，对我或多或少都是会有点感触的。</p><p>&emsp;&emsp;每个人都是从不懂到懂的，我写博客，其中的一个原因就是为了之后回顾自己之前做过的事情。看看之前的自己和现在的自己发生了什么变化，不管是学习方面还是生活方面都是一样的。我们都是一样的，没写文章的时候感觉自己很厉害，啥都懂，但是写的时候却写不出来，这其实就是对这个知识理解得不够透彻，从而可以认识自己的不足，进而才会改变自己。</p><p>&emsp;&emsp;我希望可以认识更多志同道合的朋友，互相讨论，互相弥补缺点，所以我也添加了”留言区”这个功能。希望将来来到我的博客的朋友们，都来发表发表自己的看法吧，说一说对于我写的某些东西的不足以及微乎其微的亮点吧。</p><p>&emsp;&emsp;多的不说了，以后我都会把他们记录在我的博客里面。</p><p>&emsp;&emsp;晚安</p><!--title         Markdown 的文件标题              文章标题，强烈建议填写此选项date          文件创建时的日期时间             发布时间，强烈建议填写此选项，且最好保证全局唯一author        根 _config.yml 中的 author      文章作者img            featureImages 中的某个值        文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: http://xxx.com/xxx.jpgtop            true                            推荐文章（文章是否置顶），如果 top 值为 true，则会作为首页推荐文章cover          false                            表示该文章是否需要加入到首页轮播封面中coverImg       无                            表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片password        无                               文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 password 的值，该值必须是用 SHA256 加密后的密码，防止被他人识破。前提是在主题的 config.yml 中激活了 verifyPassword 选项toc            true                             是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 config.yml 中激活了 toc 选项mathjax        false                             是否开启数学公式支持 ，本文章是否开启 mathjax，且需要在主题的 _config.yml 文件中也需要开启才行summary          无                             文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要categories       无                             文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类tags            无                              文章标签，一篇文章可以多个标签 -->]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> Markdown </tag>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
