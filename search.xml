<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++基础——对C的增强</title>
      <link href="/2019/11/15/c-ji-chu-dui-c-de-zeng-qiang-yi/"/>
      <url>/2019/11/15/c-ji-chu-dui-c-de-zeng-qiang-yi/</url>
      
        <content type="html"><![CDATA[<h2 id="C-基础——对C的增强"><a href="#C-基础——对C的增强" class="headerlink" title="C++基础——对C的增强"></a>C++基础——对C的增强</h2><p>我们都知道C++是完全兼容C的，而且对C做了一定的优化。</p><p>C++与C的不同在于：</p><h2 id="1-实用性的增强：变量可以任意定义了"><a href="#1-实用性的增强：变量可以任意定义了" class="headerlink" title="1.实用性的增强：变量可以任意定义了"></a>1.实用性的增强：变量可以任意定义了</h2><h3 id="在C中：变量的定义必须在函数使用之前，不然在早期的编译器中可能出错。"><a href="#在C中：变量的定义必须在函数使用之前，不然在早期的编译器中可能出错。" class="headerlink" title="在C中：变量的定义必须在函数使用之前，不然在早期的编译器中可能出错。"></a>在C中：变量的定义必须在函数使用之前，不然在早期的编译器中可能出错。</h3><pre><code>int i = 0;for(i = 0; i &lt; 10; i++) {    printf(&quot;Hello C&quot;);}</code></pre><h3 id="在C-中：变量可以任意定义，不过要注意变量的作用域和生存周期。"><a href="#在C-中：变量可以任意定义，不过要注意变量的作用域和生存周期。" class="headerlink" title="在C++中：变量可以任意定义，不过要注意变量的作用域和生存周期。"></a>在C++中：变量可以任意定义，不过要注意变量的作用域和生存周期。</h3><pre><code>for(int i = 0; i &lt; 10; i++) {    // 这里的i会随for循环的结束而被释放    cout &lt;&lt; &quot;Hello CPP&quot;;}</code></pre><h2 id="2-对全局检测能力的增强：不允许有重定义的现象出现"><a href="#2-对全局检测能力的增强：不允许有重定义的现象出现" class="headerlink" title="2.对全局检测能力的增强：不允许有重定义的现象出现"></a>2.对全局检测能力的增强：不允许有重定义的现象出现</h2><h3 id="在C-中：一个变量不管是声明还是定义只能出现一次"><a href="#在C-中：一个变量不管是声明还是定义只能出现一次" class="headerlink" title="在C++中：一个变量不管是声明还是定义只能出现一次"></a>在C++中：一个变量不管是声明还是定义只能出现一次</h3><pre><code>// int g_val;// int g_val = 10;// 这样定义在C中不回报错，但是在C++中会报错</code></pre><h2 id="3-对struct的增强"><a href="#3-对struct的增强" class="headerlink" title="3.对struct的增强"></a>3.对struct的增强</h2><pre><code>struct teacher {    int id;    char name[64];};void test() {    //在C语言中只能struct teacher t;这样定义除非加上typedef    //而在C++可以这样：    teacher t;}</code></pre><h2 id="4-对函数检测增强"><a href="#4-对函数检测增强" class="headerlink" title="4.对函数检测增强"></a>4.对函数检测增强</h2><h3 id="在C-中：对形参传递，返回值做了严格的检查，不允许任意传，任意调用，必须有返回值。"><a href="#在C-中：对形参传递，返回值做了严格的检查，不允许任意传，任意调用，必须有返回值。" class="headerlink" title="在C++中：对形参传递，返回值做了严格的检查，不允许任意传，任意调用，必须有返回值。"></a>在C++中：对形参传递，返回值做了严格的检查，不允许任意传，任意调用，必须有返回值。</h3><h3 id="在C中：可以任意，不过一般按照规范去写。"><a href="#在C中：可以任意，不过一般按照规范去写。" class="headerlink" title="在C中：可以任意，不过一般按照规范去写。"></a>在C中：可以任意，不过一般按照规范去写。</h3><pre><code>void f(int i) {    cout &lt;&lt; i &lt;&lt; endl; }void test3() {    f(1);    //在C中这样不会报错（warning），而在C++中这样会报错(error)。    //f(1, 2, 3);}</code></pre><h2 id="5-新增bool类型"><a href="#5-新增bool类型" class="headerlink" title="5.新增bool类型"></a>5.新增bool类型</h2><h3 id="在C语言中：非0代表真，0代表假。"><a href="#在C语言中：非0代表真，0代表假。" class="headerlink" title="在C语言中：非0代表真，0代表假。"></a>在C语言中：非0代表真，0代表假。</h3><pre><code>void test() {    int flag =1;//真    int flag=-1;//真    int flag=0;//假}</code></pre><h3 id="在C-中：新增了一个bool变量，bool变量的值只有0或1。"><a href="#在C-中：新增了一个bool变量，bool变量的值只有0或1。" class="headerlink" title="在C++中：新增了一个bool变量，bool变量的值只有0或1。"></a>在C++中：新增了一个bool变量，bool变量的值只有0或1。</h3><pre><code>void test() {    bool flag = true;    flag = false;//true--真，false--假    cout &lt;&lt; &quot;bool的size=&quot;&lt;&lt;sizeof(flag) &lt;&lt; endl;//1个字节    cout &lt;&lt; &quot;flag=&quot; &lt;&lt; flag &lt;&lt; endl;//为true值为1，为false值为0，不管为bool类型赋非0值则为1（true）,bool值只有0/1}</code></pre><h2 id="6-对三目运算符的增强"><a href="#6-对三目运算符的增强" class="headerlink" title="6.对三目运算符的增强"></a>6.对三目运算符的增强</h2><h3 id="在C中：a-gt-b-a-b-30一般会编译出错。原因是a-gt-b-a-b返回的是10，10-30会出错"><a href="#在C中：a-gt-b-a-b-30一般会编译出错。原因是a-gt-b-a-b返回的是10，10-30会出错" class="headerlink" title="在C中：a &gt; b ? a : b = 30一般会编译出错。原因是a &gt; b ? a : b返回的是10，10 = 30会出错"></a>在C中：a &gt; b ? a : b = 30一般会编译出错。原因是a &gt; b ? a : b返回的是10，10 = 30会出错</h3><h3 id="而在C-中：a-gt-b-a-b返回的是对b的引用。"><a href="#而在C-中：a-gt-b-a-b返回的是对b的引用。" class="headerlink" title="而在C++中：a &gt; b ? a : b返回的是对b的引用。"></a>而在C++中：a &gt; b ? a : b返回的是对b的引用。</h3><blockquote><p>注意：a &gt; b ? a : b作为左值时返回的结果不能有常量（常量不能取地址）。做右值时任意</p></blockquote><pre><code>void test(){    int a = 10;    int b = 20;    int max = 0;    max = a &gt; b ? a : b;    printf(&quot;%d\n&quot;,max);    //c：    //(a &gt; b ? a : b) = 30;    这样是错误的    *(a &gt; b ? &amp;a : &amp;b) = 30;    // 可以通过指针改变地址。    //c++:    (a &gt; b ? a : b) = 30;//在c中这个会出错20=30没有意义，在c++中可以使用a &gt; b ? a : b 返回b变量的引用        相当于：*(a&gt;b?&amp;a:&amp;b)=30    cout &lt;&lt; &quot;b=&quot; &lt;&lt; b &lt;&lt; endl;//30    //a &gt; b ? 10 : b = 30;//error,作为左值时返回的结果不能有常量（常量不能取地址），做右值时任意。}</code></pre><h2 id="7-const增强"><a href="#7-const增强" class="headerlink" title="7.const增强"></a>7.const增强</h2><h3 id="在C中："><a href="#在C中：" class="headerlink" title="在C中："></a>在C中：</h3><ol><li><p>const并不是一个常量，是一个变量加了只读属性。</p></li><li><p>const int 和 int const 是一样的。</p></li><li><p>const修饰的变量实际上是可以通过指针改变的，是一个假的常量。</p><pre><code> void test() {     const int a = 10;     int* p = &amp;a;     *p = 70;     printf(&quot;%d\n&quot;,a);    // 70 }</code></pre></li><li><p>与#define是有区别的。#define在预编译时处理，const在编译时处理。</p></li></ol><h3 id="const-int-c-int-const-c-和-const-int-count-的区别："><a href="#const-int-c-int-const-c-和-const-int-count-的区别：" class="headerlink" title="const int* c , int* const c 和 const int* count 的区别："></a>const int* c , int* const c 和 const int* count 的区别：</h3><ul><li>前者修饰const int表示指针C指向的地址的值不能改变，但是可以指向不同的地址。</li><li>中间修饰int 表示指针C不可以改变，但是指向的地址可以改变。</li><li>后者表示指针C不可以改变，指针指向的地址也不可以改变。</li></ul><h3 id="在c-中："><a href="#在c-中：" class="headerlink" title="在c++中："></a>在c++中：</h3><ol><li><p>const修饰表示的就是常量。const int a=1;这在C++中并不会在栈空间中开辟空间，而在内存中会有一个符号表去记录key—value。</p></li><li><p>a实际上是一个符号，是不能去访问地址的，但C++发现对一个const常量符号取地址时，会临时在栈上开辟一个临时空间，这个变量是匿名的，p–&gt;临时变量。</p></li></ol><h2 id="8-enum的增强"><a href="#8-enum的增强" class="headerlink" title="8.enum的增强"></a>8.enum的增强</h2><h3 id="C语言中枚举本质就是整型，枚举变量可以用任意整型赋值，而C-中枚举变量，只能用被枚举出来的元素初始化。"><a href="#C语言中枚举本质就是整型，枚举变量可以用任意整型赋值，而C-中枚举变量，只能用被枚举出来的元素初始化。" class="headerlink" title="C语言中枚举本质就是整型，枚举变量可以用任意整型赋值，而C++中枚举变量，只能用被枚举出来的元素初始化。"></a>C语言中枚举本质就是整型，枚举变量可以用任意整型赋值，而C++中枚举变量，只能用被枚举出来的元素初始化。</h3><pre><code>enum num {    a = 0,    b,    c,    d};void test() {    enum num n = a;    /*n = 0;    n = 1;    n = 2;    n = 3;*/    //在C语言中给枚举类型赋值时，可以通过枚举值赋值，而在C++中不可以}</code></pre><h2 id="9-引用的基本概念"><a href="#9-引用的基本概念" class="headerlink" title="9.引用的基本概念"></a>9.引用的基本概念</h2><ol><li>引用没有定义，是一种关系型声明。声明它和原有某一变量（实体）的关系。故而类型与原类型保持一致，且不分配内存。与被引用的变量有相同的内存地址。</li><li>声明的时候必须初始化，一经声明，不可变更。 </li><li>可对引用，再次引用。多次引用的结果，是某一变量具有多个别名。</li><li>&amp; 符号前有数据类型时，是引用，例如：int&amp;，double&amp;。其它皆为取地址。</li></ol><pre><code>#include&lt;iostream&gt;using namespace std;void change_value(int&amp; r) {    r = 30;}int main() {    int a = 20;    int b = 30;    int *p = &amp;a;    *p = 30;    cout &lt;&lt; a &lt;&lt; endl;    // 30    p = &amp;b;    *p = 20;    cout &lt;&lt; b &lt;&lt; endl;    // 20    int&amp; re = a;    // int&amp; 使用引用数据类型，re就是a的别名。     re = 50;    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;    // 50    // int&amp; re;    引用必须初始化。    int&amp; re2 = re;    // 可对引用，再次引用。    re2 = 60;    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;    cout &lt;&lt; &quot;-----------------&quot;&lt;&lt; endl;    change_value(a);    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;    return 0;}</code></pre><ol start="5"><li>通过引用 可以降低需要改变地址值时的难度。</li><li>引用作为函数的参数 </li></ol><pre><code>#include&lt;iostream&gt;using namespace std;struct student{    int id;    char name[64];};// 使用指针的方法 交换两个数的值 void swap(int* a, int* b) {    int temp;    temp = *a;    *a = *b;    *b = temp;}// 使用引用的方法 交换两个数的值 void swap2(int&amp; a, int&amp; b) {    int temp;    temp = a;    a = b;    b = temp;}// 使用普通的方法 void prints(student s) {    // 相当于 student s = s1; 变成了拷贝操作，不建议这样。     cout &lt;&lt; s.id &lt;&lt; &quot;\t&quot;&lt;&lt; s.name &lt;&lt; endl;}// 使用指针的方法 void prints2(student* s) {    // 相当于 student* s = &amp;s1;      cout &lt;&lt; s-&gt;id &lt;&lt; &quot;\t&quot;&lt;&lt; s-&gt;name &lt;&lt; endl;}// 使用引用的方法 void prints3(student&amp; s) {    // 相当于 student* s = &amp;s1;      cout &lt;&lt; s.id &lt;&lt; &quot;\t&quot;&lt;&lt; s.name &lt;&lt; endl;}int main() {    int a = 10, b = 20;//    swap(&amp;a, &amp;b);    swap2(a, b);    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;    cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;    student s1 = {10, &quot;zhangsan&quot;};    prints(s1);    prints2(s1);    prints3(s1);    return 0;} </code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>实用性增强（变量定义），全局变量定义检查（严格），变量类型检查严格，所有变量和函数定义必须有类型。</li><li>struct关键字（c中不是新类型），与class功能相同。</li><li>类型加强 bool 1个字节，但是只有 true 和 false。</li><li>C++中三目运算符，返回变量自身，C返回的是变量的值。</li><li>const增强<ul><li>指针变量和它所指向的内存空间变量是两个不同的概念。</li><li>C中冒牌货（只读变量有自己的存储空间）。</li><li>C++ const是一个只读常量，符号表机制，不可分配内存。</li><li>const是由编译器处理的，提供类型检查和作用域检查。</li><li>#define宏定义有预处理器处理，单纯的文本替换。</li></ul></li><li>引用<ul><li>引用没有定义，是一种关系型声明。声明它和原有某一变量（实体）的关系。故而类型与原类型保持一致，且不分配内存。与被引用的变量有相同的内存地址。</li><li>声明的时候必须初始化，一经声明，不可变更。 </li><li>可对引用，再次引用。多次引用的结果，是某一变量具有多个别名。</li><li>&amp; 符号前有数据类型时，是引用，例如：int&amp;，double&amp;。其它皆为取地址。</li><li>通过引用 可以降低需要改变地址值时的难度（好用）。</li><li>引用作为函数的参数。</li></ul></li></ol><p>&emsp;&emsp;晚安</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> Markdown </tag>
            
            <tag> C++基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客</title>
      <link href="/2019/11/13/wo-de-di-yi-pian-blog/"/>
      <url>/2019/11/13/wo-de-di-yi-pian-blog/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;<strong>忙碌了将近一天，终于把这个博客网站搭上了，哈哈哈，奈何自己太菜，只能用Hexo来写啦，搭这个博客的初衷很简单，就是想记录一下自己的经历吧。因为第一次搭博客，所以也遇见了一点小问题（具体的也忘记了。。。），不过什么也是自己琢磨出来的，总不能因为这点小小的问题就放弃把，失败就失败，大不了重来呗，我们还年轻，有的是机会重来。</strong></p><h3 id="我为什么要写博客？"><a href="#我为什么要写博客？" class="headerlink" title="我为什么要写博客？"></a><em>我为什么要写博客</em>？</h3><p>&emsp;&emsp;不管做什么事，总得知道做这件事的原因，做这件事的目的吧。</p><p>&emsp;&emsp;写博客对于我来说有什么或者将会带来什么好处，针对我个人而言，我认为写博客的最重要作用就是记录自己的成长足迹，因为它可以记录我各个阶段做了什么，收获了什么，不管是写技术博客，还是记录生活经历的博客，对我或多或少都是会有点感触的。</p><p>&emsp;&emsp;每个人都是从不懂到懂的，我写博客，其中的一个原因就是为了之后回顾自己之前做过的事情。看看之前的自己和现在的自己发生了什么变化，不管是学习方面还是生活方面都是一样的。我们都是一样的，没写文章的时候感觉自己很厉害，啥都懂，但是写的时候却写不出来，这其实就是对这个知识理解得不够透彻，从而可以认识自己的不足，进而才会改变自己。</p><p>&emsp;&emsp;我希望可以认识更多志同道合的朋友，互相讨论，互相弥补缺点，所以我也添加了”留言区”这个功能。希望将来来到我的博客的朋友们，都来发表发表自己的看法吧，说一说对于我写的某些东西的不足以及微乎其微的亮点吧。</p><p>&emsp;&emsp;多的不说了，以后我都会把他们记录在我的博客里面。</p><p>&emsp;&emsp;晚安</p><!--title         Markdown 的文件标题              文章标题，强烈建议填写此选项date          文件创建时的日期时间             发布时间，强烈建议填写此选项，且最好保证全局唯一author        根 _config.yml 中的 author      文章作者img            featureImages 中的某个值        文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: http://xxx.com/xxx.jpgtop            true                            推荐文章（文章是否置顶），如果 top 值为 true，则会作为首页推荐文章cover          false                            表示该文章是否需要加入到首页轮播封面中coverImg       无                            表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片password        无                               文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 password 的值，该值必须是用 SHA256 加密后的密码，防止被他人识破。前提是在主题的 config.yml 中激活了 verifyPassword 选项toc            true                             是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 config.yml 中激活了 toc 选项mathjax        false                             是否开启数学公式支持 ，本文章是否开启 mathjax，且需要在主题的 _config.yml 文件中也需要开启才行summary          无                             文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要categories       无                             文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类tags            无                              文章标签，一篇文章可以多个标签 -->]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> Markdown </tag>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
