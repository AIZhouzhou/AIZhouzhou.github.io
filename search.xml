<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++标准模板库(STL)</title>
      <link href="/2019/11/18/stack/"/>
      <url>/2019/11/18/stack/</url>
      
        <content type="html"><![CDATA[<h2 id="C-标准模板块-STL-介绍"><a href="#C-标准模板块-STL-介绍" class="headerlink" title="C++标准模板块(STL)介绍"></a>C++标准模板块(STL)介绍</h2><h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><p>&emsp;&emsp;stack 翻译为栈，是 STL 中实现的一个<strong>后进先出</strong>的容器。</p><h3 id="1-stack-的定义"><a href="#1-stack-的定义" class="headerlink" title="1. stack 的定义"></a>1. stack 的定义</h3><p>&emsp;&emsp;stack 的定义的写法和其他 STL 容器相同，typename 可以任意基本数据类型或容器。</p><pre><code>stack&lt;typename&gt; name;</code></pre><h3 id="2-stack-容器内元素的访问"><a href="#2-stack-容器内元素的访问" class="headerlink" title="2. stack 容器内元素的访问"></a>2. stack 容器内元素的访问</h3><p>&emsp;&emsp;由于栈(stack) 本身就是一种后进先出的数据结构，在 STL 的 stack 中<strong>只能通过 top() 来访问栈顶元素</strong>。</p><p>&emsp;&emsp;示例如下：</p><pre><code>#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;int main() {    stack&lt;int&gt; st;    for(int i = 0; i &lt;= 5; i++) {        st.push(i);    // push(i) 用以把 i 压入栈，故此处依次入栈 1 2 3 4 5    }    cout &lt;&lt; st.top();    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>5</code></pre><h3 id="3-stack-常用函数示例解析"><a href="#3-stack-常用函数示例解析" class="headerlink" title="3. stack 常用函数示例解析"></a>3. stack 常用函数示例解析</h3><h4 id="1-push"><a href="#1-push" class="headerlink" title="(1) push()"></a>(1) push()</h4><p>&emsp;&emsp;push(x) 将 x 入栈，时间复杂度为 O(1)。</p><h4 id="2-top"><a href="#2-top" class="headerlink" title="(2) top()"></a>(2) top()</h4><p>&emsp;&emsp;top() 获得栈顶元素，时间复杂度为 O(1)。</p><h4 id="3-pop"><a href="#3-pop" class="headerlink" title="(3) pop()"></a>(3) pop()</h4><p>&emsp;&emsp;pop() 用以弹出栈顶元素，时间复杂度为 O(1)。</p><p>&emsp;&emsp;示例如下：</p><pre><code>#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;int main() {    stack&lt;int&gt; st;    for(int i = 0; i &lt;= 5; i++) {        st.push(i);    // push(i) 将 1 2 3 4 5 依次入栈    }    for(int i = 1; i &lt;= 3; i++) {        st.pop();    // 连续三次将栈顶元素出栈，即将 5 4 3 依次出栈    }    cout &lt;&lt; st.top();    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>2</code></pre><h4 id="4-empty"><a href="#4-empty" class="headerlink" title="(4) empty()"></a>(4) empty()</h4><p>&emsp;&emsp;empty() 可以检测 stack 内是否为空， 返回 true 为空，返回 false 为非空，时间复杂度为 O(1)。示例如下：</p><pre><code>#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;int main() {    stack&lt;int&gt; st;    if(st.empty() == true) {    // 一开始栈内没有元素，因此栈空        cout &lt;&lt; &quot;Empty\n&quot;;    } else {        cout &lt;&lt; &quot;Not Empty\n&quot;;    }    st.push(1);    if(st.empty() == true) {    // 入栈&quot;1&quot;后，栈非空        cout &lt;&lt; &quot;Empty\n&quot;;    } else {        cout &lt;&lt; &quot;Not Empty\n&quot;;    }    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>EmptyNot Empty</code></pre><h4 id="5-size"><a href="#5-size" class="headerlink" title="(5) size()"></a>(5) size()</h4><p>&emsp;&emsp;size() 返回 stack 元素的个数，时间复杂度为 O(1)。</p><p>&emsp;&emsp;示例如下：</p><pre><code>#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;int main() {    stack&lt;int&gt; st;    for(int i = 1; i &lt;= 5; i++) {        st.push(i);    // push(i) 将 1 2 3 4 5 依次入栈    }    cout &lt;&lt; st.size();    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>5</code></pre><h3 id="4-stack-的常见用途"><a href="#4-stack-的常见用途" class="headerlink" title="4. stack 的常见用途"></a>4. stack 的常见用途</h3><p>&emsp;&emsp;stack 用来模拟实现一些递归，防止程序对栈内存的限制而导致程序运行出错。一般来说，程序的栈内存空间很小，对有些题目来说，如果用普通的函数进行递归，一旦递归层数过深(不同机器不同，约几千至几万层)，则会导致程序运行崩溃。如果用栈来模拟递归算法的实现，则可避免这一方面的问题(不过这种应用出现比较少)。</p><p>&emsp;&emsp;晚安。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> Markdown </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++标准模板库(STL)</title>
      <link href="/2019/11/17/algorithm/"/>
      <url>/2019/11/17/algorithm/</url>
      
        <content type="html"><![CDATA[<h2 id="C-标准模板块-STL-介绍"><a href="#C-标准模板块-STL-介绍" class="headerlink" title="C++标准模板块(STL)介绍"></a>C++标准模板块(STL)介绍</h2><h2 id="algorithm-头文件下的常用函数"><a href="#algorithm-头文件下的常用函数" class="headerlink" title="algorithm 头文件下的常用函数"></a>algorithm 头文件下的常用函数</h2><h3 id="max-min-和-abs"><a href="#max-min-和-abs" class="headerlink" title="max(), min() 和 abs()"></a>max(), min() 和 abs()</h3><p>&emsp;&emsp;max(x, y) 和 min(x, y) 分别返回 x 和 y 中的最大值和最小值，且<strong>参数必须时两个（可以是浮点数）</strong>。如果想要返回三个数x, y, z 的最大值，可以使用 max(x, max(y, z)) 的写法。</p><p>&emsp;&emsp;abs(x) 返回 x 的绝对值。注意：x 必须是整数，浮点型的绝对值请用 math 头文件下的 fabs。</p><p>&emsp;&emsp;示例如下：</p><pre><code>#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main() {    int x = 1, y = -2;    cout &lt;&lt; max(x, y) &lt;&lt; &quot; &quot; &lt;&lt; min(x, y) &lt;&lt; endl;    cout &lt;&lt; abs(x) &lt;&lt; &quot; &quot; &lt;&lt; abs(y);    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>1 -21 2</code></pre><h3 id="swap"><a href="#swap" class="headerlink" title="swap()"></a>swap()</h3><p>&emsp;&emsp;swap() 用来交换 x 和 y 的值，示例如下：</p><pre><code>#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main() {    int x = 1, y = 2;    swap(x, y);    cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y;    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>2 1</code></pre><h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h3><p>&emsp;&emsp;reverse(it, it2) 可以将数组指针在 [it, it2) 之间的元素或容器的迭代器在 [it, it2) 范围内的元素进行反转。示例如下：</p><pre><code>#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main() {    int a[10] = {10, 11, 12, 13, 14, 15};    reverse(a, a + 4);    // 将 a[0] - a[3] 反转     for(int i = 0; i &lt; 6; i++) {        cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;    }    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>13 12 11 10 14 15</code></pre><p>&emsp;&emsp;如果是对容器中的元素（例如 string 字符串）进行反转，结果也是一样的：</p><pre><code>#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;using namespace std;int main() {    string str = &quot;abcdefghi&quot;;    reverse(str.begin() + 2, str.begin() + 6);    cout &lt;&lt; str;    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>abfedcghi</code></pre><h3 id="next-permutation"><a href="#next-permutation" class="headerlink" title="next_permutation()"></a>next_permutation()</h3><p>&emsp;&emsp;next_permutation() 给出一个序列在全排列中的<strong>下一个序列</strong>。</p><p>&emsp;&emsp;例如，当 n = 3 时的全排列为：</p><pre><code>123132213231312321</code></pre><p>&emsp;&emsp;这样 231 的下一个序列就是 312。</p><p>&emsp;&emsp;示例如下：</p><pre><code>#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main() {    int a[10] = {1, 2, 3};    // a[0] - a[2]之间的序列需要求解 next_permutation    do{        cout &lt;&lt; a[0] &lt;&lt; &quot; &quot; &lt;&lt; a[1] &lt;&lt; &quot; &quot; &lt;&lt; a[2] &lt;&lt; endl;    }while(next_permutation(a, a + 3));    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>1 2 31 3 22 1 32 3 13 1 23 2 1</code></pre><p>&emsp;&emsp;在上述的代码中，使用循坏是因为 next_permutation 在已经达到全排列的最后一个时会返回 false，这样会方便退出循环。而使用do···while 语句而不使用 while 语句是因为序列 1 2 3 本身也需要输出，如果使用 while 会直接跳到下一个序列在输出，这样结果就会少个 它本身。</p><h3 id="fill"><a href="#fill" class="headerlink" title="fill()"></a>fill()</h3><p>&emsp;&emsp;fill() 可以把数组或容器中的某一段区间赋为某个相同的值。和 memset 不同的是，这里赋值<strong>可以是数组类型对应范围中的任意值</strong>。示例如下：</p><pre><code>#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main() {    int a[10] = {1, 2, 3, 4, 5};    fill(a, a + 5, 233); // 将a[0] - a[4] 均赋值为 233    for(int i = 0; i &lt; 5; i++) {        cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;    }    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>233 233 233 233 233</code></pre><h3 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h3><p>&emsp;&emsp;顾名思义，sort就是用来排序的函数，他根据具体情形使用不同的排序方法，效率较高。一般来说，不推荐使用 C 语言中的 qsort 函数，原因是 qsort 用起来比较繁琐， 涉及很多指针的操作。而且 sort 在实现中避免了经典快速排序中可能出现的会导致实际复杂度退化到 O(n ^ 2) 的极端情况。</p><h4 id="1-如何使用-sort-排序"><a href="#1-如何使用-sort-排序" class="headerlink" title="1. 如何使用 sort 排序"></a>1. 如何使用 sort 排序</h4><p>&emsp;&emsp;sort 函数的使用方式：</p><pre><code>sort(首元素地址(必填), 尾元素地址的下一个地址(必填), 比较函数(非必填));</code></pre><p>&emsp;&emsp; 可以看到，sort 的参数有三个，其中前两个是必填的，而比较函数则可以根据需要填写，如果不写比较函数，则默认对前面给出的区间进行递增排序。</p><p>&emsp;&emsp;可以先从示例入手：</p><pre><code>#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main() {    int a[6] = {9, 4, 2, 5, 6, -1};    // 将 a[0] - a[3] 从小到大排序    sort(a, a + 4);    for(int i = 0; i &lt; 6; i++) {        cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;            }    cout &lt;&lt; endl;    // 将 a[0] - a[5] 从小到大排序    sort(a, a + 6);    for(int i = 0; i &lt; 6; i++) {        cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;    }    return 0;}</code></pre><p>&emsp;&emsp;运行之后可以得到下面的结果，可以试着理解一下(特别注意理解 “尾元素地址的下一个地址”)。输出结果：</p><pre><code>2 4 5 9 6 -1-1 2 4 5 6 9</code></pre><p>&emsp;&emsp;又如，对 double型 数组排序：</p><pre><code>#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main() {    double a[] = {1.4, -2.1, 9};    sort(a, a + 3);    for(int i = 0; i &lt; 3; i++) {        cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;            }    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>-2.1 1.4 9</code></pre><p>&emsp;&emsp;再如，对 char 型数组排序(默认为字典序)：</p><pre><code>#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main() {    char a[] = {&#39;T&#39;, &#39;W&#39;, &#39;A&#39;, &#39;K&#39;};    sort(a, a + 4);    for(int i = 0; i &lt; 4; i++) {        cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;            }    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>A K T W</code></pre><p>&emsp;&emsp;sort 的第三个可选参数就是 compare 函数(一般写作 cmp 函数)，用来实现这个规则：</p><h4 id="2-如何实现比较函数cmp"><a href="#2-如何实现比较函数cmp" class="headerlink" title="2. 如何实现比较函数cmp"></a>2. 如何实现比较函数cmp</h4><p>&emsp;&emsp;下面介绍对基本数据类型，结构体类型，STL容器进行自定义规则排序时 cmp 的写法。</p><h5 id="1-基本数据类型数组的排序"><a href="#1-基本数据类型数组的排序" class="headerlink" title="(1) 基本数据类型数组的排序"></a>(1) 基本数据类型数组的排序</h5><p>&emsp;&emsp;若比较函数不填，则默认按照从小到大的顺序排序。下面是对 int型数组的排序：</p><pre><code>#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main() {    int a[5] = {3, 1, 4, 2};    sort(a, a + 4);    for(int i = 0; i &lt; 4; i++) {        cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;    }    return 0;}</code></pre><p>&emsp;&emsp;</p><pre><code>1 2 3 4</code></pre><p>&emsp;&emsp;如果想要从小到大来排序，则要使用比较函数 cmp 来 “告诉” sort何时要交换元素(让元素的大小比较关系反过来)。还是上面那个例子，这里比较的元素是 int 类型，可以这样写：</p><pre><code>#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;bool cmp(int a, int b) {    return a &gt; b;    // 可以理解为当 a &gt; b 时把 a 放在 b 的前面。}int main() {    int a[5] = {3, 1, 4, 2};    sort(a, a + 4, cmp);    for(int i = 0; i &lt; 4; i++) {        cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;    }    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>4 3 2 1</code></pre><p>&emsp;&emsp;这样就可以让数值较大的元素放在前面，也就达到了从大到小排序的要求。</p><p>&emsp;&emsp;同样的，对 double型数组从大到小的代码如下：</p><pre><code>#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;bool cmp(double a, double b) {    return a &gt; b;    // 可以理解为当 a &gt; b 时把 a 放在 b 的前面。}int main() {    double a[3] = {1.4, -2.1, 9};    sort(a, a + 3, cmp);    for(int i = 0; i &lt; 3; i++) {        cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;    }    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>9 1.4 -2.1</code></pre><p>&emsp;&emsp;对 char 型数组从大到小排序的代码如下：</p><pre><code>#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;bool cmp(char a, char b) {    return a &gt; b;    // 可以理解为当 a &gt; b 时把 a 放在 b 的前面。}int main() {    char a[] = {&#39;T&#39;, &#39;W&#39;, &#39;A&#39;, &#39;K&#39;};    sort(a, a + 4, cmp);    for(int i = 0; i &lt; 4; i++) {        cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;    }    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>W T K A</code></pre><p><strong>记忆方法</strong>：如果要把数据从小到大排序，那么就用 “&lt;”，因为 “a &lt; b”就是左小右大；如果要把数据从大到小排序，那么就用 “&gt;”，就是左大右小。而不确定或者忘记时，不妨两种都试一下，就会知道该用哪种了。</p><h5 id="2-结构体数组的排序"><a href="#2-结构体数组的排序" class="headerlink" title="(2) 结构体数组的排序"></a>(2) 结构体数组的排序</h5><p>&emsp;&emsp;现在定义了如下的结构体：</p><pre><code>struct node {    int x, y;}ssd[10];</code></pre><p>&emsp;&emsp;如果想将 ssd 数组按照 x 从大到小排序(即进行一级排序)，那么可以这样写 cmp 函数。</p><p>&emsp;&emsp;</p><pre><code>bool cmp (node a, node b) {    return a.x &gt; b.x;}</code></pre><p>&emsp;&emsp;示例如下：</p><pre><code>#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;struct node {    int x, y;}ssd[10];bool cmp(node a, node b) {    return a.x &gt; b.x;    // 可以理解为当 a &gt; b 时把 a 放在 b 的前面。}int main() {    ssd[0].x = 2;    ssd[0].y = 2;    ssd[1].x = 1;    ssd[1].y = 3;    ssd[2].x = 3;    ssd[2].y = 1;    sort(ssd, ssd + 3, cmp);    // 排序    for(int i = 0; i &lt; 3; i++) {        cout &lt;&lt; ssd[i].x &lt;&lt; &quot; &quot; &lt;&lt; ssd[i].y &lt;&lt; endl;    }    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>3 12 21 3</code></pre><p>&emsp;&emsp;而如果想先按 x 从大到小排序，但当 x 相等的情况下，按照 y 的从小到大来排序(即进行二级排序)，那么 cmp 的写法是：</p><pre><code>bool cmp node(node a, node b) {    if(a.x != b.x) return a.x &gt; b.x;    else return a.y &lt; b.y;}</code></pre><p>&emsp;&emsp;这里的 cmp 函数首先判断结构体内的 x 元素是否相等，如果不相等，则直接按照 x 的大小来排序；否则，比较两个结构体中 y 的大小，并按 y 从小到大排序。</p><p>&emsp;&emsp;</p><pre><code>#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;struct node {    int x, y;}ssd[10];bool cmp(node a, node b) {    return a.x &gt; b.x;    // 因为 vector 中的元素为 int型，因此依然是 int 的比较。 }int main() {    vector&lt;int&gt; vi;    vi.push_back(3);    vi.push_back(1);    vi.push_back(2);        sort(vi.begin(), vi.end(), cmp);    // 对整个 vector 排序    for(int i = 0; i &lt; 3; i++) {        cout &lt;&lt; vi[i] &lt;&lt; &quot; &quot;;    }    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>2 12 21 3</code></pre><h5 id="3-容器的排序"><a href="#3-容器的排序" class="headerlink" title="(3) 容器的排序"></a>(3) 容器的排序</h5><p>&emsp;&emsp;在 STL 标准容器中，只有 vector，string，deque 是可以使用 sort 的。这是因为想 set，map这种容器使用红黑树实现的，元素本身有序，故不允许使用 sort 排序。</p><p>&emsp;&emsp;下面以 vector 为例：</p><pre><code>#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;bool cmp(int a, int b) {    return a &gt; b;    // 因为 vector 中的元素为 int型，因此依然是 int 的比较。 }int main() {    vector&lt;int&gt; vi;    vi.push_back(3);    vi.push_back(1);    vi.push_back(2);        sort(vi.begin(), vi.end(), cmp);    // 对整个 vector 排序    for(int i = 0; i &lt; 3; i++) {        cout &lt;&lt; vi[i] &lt;&lt; &quot; &quot;;    }    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>3 2 1</code></pre><p>&emsp;&emsp;再来看 string 的排序：</p><pre><code>#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;using namespace std;int main() {    string str[3] = {&quot;bbbb&quot;, &quot;cc&quot;, &quot;aaa&quot;};    sort(str, str + 3);    for(int i = 0; i &lt; 3; i++) {        cout &lt;&lt; str[i] &lt;&lt; &quot; &quot;;    }    return 0;}</code></pre><p>&emsp;&emsp;上面的代码输出如下：</p><pre><code>aaa bbbb cc</code></pre><p>&emsp;&emsp;如果上面这个例子中，想要按字符串长度从小到大排序，那么可以这样写：</p><pre><code>#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;using namespace std;bool cmp(string str1, string str2) {    return str1.length() &lt; str2.length();// 按 string 的长度从小到大排序。}int main() {    string str[3] = {&quot;bbbb&quot;, &quot;cc&quot;, &quot;aaa&quot;};    sort(str, str + 3, cmp);    for(int i = 0; i &lt; 3; i++) {        cout &lt;&lt; str[i] &lt;&lt; &quot; &quot;;    }    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>cc aaa bbbb</code></pre><h3 id="lower-bound-和-upper-bound"><a href="#lower-bound-和-upper-bound" class="headerlink" title="lower_bound() 和 upper_bound()"></a>lower_bound() 和 upper_bound()</h3><p>&emsp;&emsp;lower_bound() 和 upper_bound() 需要用在一个有序数组或容器中。</p><p>&emsp;&emsp;lower_bound(first, last, val) 用来寻找在数组或容器的 [first, last) 范围内 <strong>第一个值大于等于val</strong>的元素的位置，如果是数组，则返回该位置的指针；如果是容器，则返回该位置的迭代器。</p><p>&emsp;&emsp;upper_bound(first, last, val) 用来寻找在数组或容器的 [first, last) 范围内 <strong>第一个值大于val</strong>的元素的位置，如果是数组，则返回该位置的指针；如果是容器，则返回该位置的迭代器。</p><p>&emsp;&emsp;示例如下：</p><pre><code>#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main() {    int a[10] = {1, 2, 2, 3, 3, 3, 5, 5, 5, 5};    int *lowerPos = lower_bound(a, a + 10, -1);    int *upperPos = upper_bound(a, a + 10, -1);    cout &lt;&lt; lowerPos - a &lt;&lt; &quot; &quot; &lt;&lt; upperPos - a &lt;&lt; endl;    lowerPos = lower_bound(a, a + 10, 1);    upperPos = upper_bound(a, a + 10, 1);    cout &lt;&lt; lowerPos - a &lt;&lt; &quot; &quot; &lt;&lt; upperPos - a &lt;&lt; endl;    lowerPos = lower_bound(a, a + 10, 3);    upperPos = upper_bound(a, a + 10, 3);    cout &lt;&lt; lowerPos - a &lt;&lt; &quot; &quot; &lt;&lt; upperPos - a &lt;&lt; endl;    lowerPos = lower_bound(a, a + 10, 4);    upperPos = upper_bound(a, a + 10, 4);    cout &lt;&lt; lowerPos - a &lt;&lt; &quot; &quot; &lt;&lt; upperPos - a &lt;&lt; endl;    lowerPos = lower_bound(a, a + 10, 6);    upperPos = upper_bound(a, a + 10, 6);    cout &lt;&lt; lowerPos - a &lt;&lt; &quot; &quot; &lt;&lt; upperPos - a &lt;&lt; endl;    return 0;}</code></pre><p>&emsp;&emsp; 输出结果：</p><pre><code>0 00 13 66 610 10</code></pre><p>&emsp;&emsp;显然，如果只是想获得欲查元素的下标，就可以不使用指针，而<strong>直接令返回值减去数组首地址即可</strong>：</p><pre><code>#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main() {    int a[10] = {1, 2, 2, 3, 3, 3, 5, 5, 5, 5};    cout &lt;&lt; lower_bound(a, a + 10, 3) - a &lt;&lt; &quot; &quot; &lt;&lt; upper_bound(a, a + 10, 3) - a;    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>3 6</code></pre><p>&emsp;&emsp;晚安。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> Markdown </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++标准模板库(STL)</title>
      <link href="/2019/11/17/pair/"/>
      <url>/2019/11/17/pair/</url>
      
        <content type="html"><![CDATA[<h2 id="C-标准模板块-STL-介绍"><a href="#C-标准模板块-STL-介绍" class="headerlink" title="C++标准模板块(STL)介绍"></a>C++标准模板块(STL)介绍</h2><h2 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h2><p>&emsp;&emsp;pair 是一个很实用的”小玩意”，当想要将两个元素绑在一起作为一个合成元素，又不想要因此定义结构体时，使用 pair 可以很方便地作为一个替代品。也就是说，pair 实际上可以看作一个内部有两个元素的结构体，且这两个元素的类型是可以指定的，如下面的短代码所示：</p><pre><code>struct pair {    typeName1 first;    typeName2 second;};</code></pre><h3 id="1-pair-的定义"><a href="#1-pair-的定义" class="headerlink" title="1. pair 的定义"></a>1. pair 的定义</h3><p>&emsp;&emsp;pair 有两个参数，分别对应 first 和 second 的数据类型，他们可以是任意基本数据类型或容器。</p><pre><code>pair&lt;typeName1, typeName2&gt; name;</code></pre><p>&emsp;&emsp;因此，想要定义参数为 string 和 int 类型的 pair，就可以使用如下写法：</p><pre><code>pair&lt;string, int&gt; p;</code></pre><p>&emsp;&emsp;如果想在定义 pair 时进行初始化，只需要跟上一个小括号，里面填写两个想要初始化元素即可：</p><pre><code>pair&lt;string, int&gt; p(&quot;haha&quot;, 5);</code></pre><p>&emsp;&emsp;而如果想在代码中临时构建一个 pair，有如下两种方法：</p><p>&emsp;&emsp;① 将类型定义写在前面，后面用小括号内两个元素的方式。</p><pre><code>pair&lt;string, int&gt;(&quot;haha&quot;, 5);</code></pre><p>&emsp;&emsp;② 使用自带的 make_pair 函数。</p><pre><code>make_pair(&quot;haha&quot;, 5);</code></pre><h3 id="2-pair-中元素的访问"><a href="#2-pair-中元素的访问" class="headerlink" title="2. pair 中元素的访问"></a>2. pair 中元素的访问</h3><p>&emsp;&emsp;pair 中只有两个元素，分别是 first 和 second，只需要按正常结构体的方式去访问即可。</p><p>&emsp;&emsp;示例如下：</p><pre><code>#include&lt;iostream&gt;#include&lt;utility&gt;#include&lt;string&gt;using namespace std;int main() {    pair&lt;string, int&gt; p;    p.first = &quot;haha&quot;;    p.second = 5;    cout &lt;&lt; p.first &lt;&lt; &quot; &quot; &lt;&lt; p.second &lt;&lt; endl;    p = make_pair(&quot;xixi&quot;, 55);    cout &lt;&lt; p.first &lt;&lt; &quot; &quot; &lt;&lt; p.second &lt;&lt; endl;    p = pair&lt;string, int&gt; (&quot;heihei&quot;, 555);    cout &lt;&lt; p.first &lt;&lt; &quot; &quot; &lt;&lt; p.second &lt;&lt; endl;    return 0;    }</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>haha 5xixi 55heihei 555</code></pre><h3 id="3-pair-常用函数示例解析"><a href="#3-pair-常用函数示例解析" class="headerlink" title="3. pair 常用函数示例解析"></a>3. pair 常用函数示例解析</h3><h4 id="比较操作数"><a href="#比较操作数" class="headerlink" title="比较操作数"></a>比较操作数</h4><p>&emsp;&emsp;两个 pair 类型数据就可以直接使用 ==，!=，&lt;，&lt;=，&gt;，&gt;= 比较大小，比较规则是<strong>先以 first 的大小作为标准，只有当 first 相等时才去判别 second 的大小</strong>。</p><p>&emsp;&emsp;示例如下：</p><pre><code>#include&lt;iostream&gt;#include&lt;utility&gt;using namespace std;int main() {    pair&lt;int, int&gt; p1(5, 10);    pair&lt;int, int&gt; p2(5, 15);    pair&lt;int, int&gt; p3(10, 5);    if(p1 &lt; p3) cout &lt;&lt; &quot;p1 &lt; p3\n&quot;;    if(p1 &lt;= p3) cout &lt;&lt; &quot;p1 &lt;= p3\n&quot;;    if(p1 &lt; p2) cout &lt;&lt; &quot;p1 &lt; p2\n&quot;;    return 0;    }</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>p1 &lt; p3p1 &lt;= p3p1 &lt; p2</code></pre><h3 id="4-pair-的常见用途"><a href="#4-pair-的常见用途" class="headerlink" title="4. pair 的常见用途"></a>4. pair 的常见用途</h3><p>&emsp;&emsp;关于 pair 有两种比较常见的例子：</p><p>&emsp;&emsp;① 用来代替二元结构体及其构造函数，可以节省编码时间。</p><p>&emsp;&emsp;② 作为 map 的键值对来进行插入，例如下面的例子。</p><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;map&gt;int main() {    map&lt;string, int&gt; mp;    mp.insert(make_pair(&quot;heihie&quot;, 5));    mp.insert(pair&lt;string, int&gt;(&quot;haha&quot;, 10));    for(map&lt;string, int&gt;::iterator it = mp.begin(); it != mp.end(); it++) {        cout &lt;&lt; it -&gt; first &lt;&lt; &quot; &quot; &lt;&lt; it -&gt; second &lt;&lt; endl;    }    return 0;} </code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>haha 10heihie 5</code></pre><p>&emsp;晚安。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> Markdown </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++标准模板库(STL)</title>
      <link href="/2019/11/17/priority-queue/"/>
      <url>/2019/11/17/priority-queue/</url>
      
        <content type="html"><![CDATA[<h2 id="C-标准模板块-STL-介绍"><a href="#C-标准模板块-STL-介绍" class="headerlink" title="C++标准模板块(STL)介绍"></a>C++标准模板块(STL)介绍</h2><h2 id="priority-queue-优先队列"><a href="#priority-queue-优先队列" class="headerlink" title="priority_queue(优先队列)"></a>priority_queue(优先队列)</h2><p>&emsp;&emsp;priority_queuec又称为优先队列，其底层是用 <strong>堆</strong> 实现的。在优先队列中，<strong>队首元素一定是当前对列中优先级最高的那一个</strong>。例如在队列中有如下元素，且定义好了优先级：</p><pre><code>桃子(3)李子(4)苹果(1)</code></pre><p>那么出队的顺序为李子(4) -&gt; 桃子(3) -&gt; 苹果(1)。</p><p>&emsp;&emsp;当然，可以在任何时候往优先队列里面加入(push)元素，而优先队列底层的数据结构堆(heap)会随时调整结构，使得<strong>每次的队首元素都是优先级最大的</strong>。（这里的优先级是定义出来的）</p><h3 id="1-priority-queue-的定义"><a href="#1-priority-queue-的定义" class="headerlink" title="1. priority_queue 的定义"></a>1. priority_queue 的定义</h3><pre><code>priority_queue&lt;typename&gt; name;</code></pre><h3 id="2-priority-queue-容器内元素的访问"><a href="#2-priority-queue-容器内元素的访问" class="headerlink" title="2. priority_queue 容器内元素的访问"></a>2. priority_queue 容器内元素的访问</h3><p>&emsp;&emsp;和队列不一样的是，优先队列没有 front()函数与back()函数，而<strong>只能通过 top()函数来访问队首元素(也可以成为堆顶元素)，也就是优先级最高的元素。</strong></p><p>&emsp;&emsp;示例如下：</p><pre><code>#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;int main() {    priority_queue&lt;int&gt; q;    q.push(3);    q.push(4);    q.push(1);    cout &lt;&lt; q.top();    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>4</code></pre><h3 id="3-priority-queue-常用函数解析"><a href="#3-priority-queue-常用函数解析" class="headerlink" title="3. priority_queue 常用函数解析"></a>3. priority_queue 常用函数解析</h3><h4 id="1-push"><a href="#1-push" class="headerlink" title="(1) push()"></a>(1) push()</h4><p>&emsp;&emsp;push(x)将令 x 入队，时间复杂度为 O(logN)，其中 N 为当前优先队列中的元素的个数。</p><h4 id="2-top"><a href="#2-top" class="headerlink" title="(2) top()"></a>(2) top()</h4><p>&emsp;&emsp;top() 可以令队首元素(即堆顶元素)出队，时间复杂度为 O(logN)，其中 N 为当前优先队列中的元素个数。</p><p>&emsp;&emsp;示例如下：</p><pre><code>#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;int main() {    priority_queue&lt;int&gt; q;    q.push(3);    q.push(4);    q.push(1);    cout &lt;&lt; q.top() &lt;&lt; endl;    q.pop();    cout &lt;&lt; q.top();    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>43</code></pre><h4 id="4-empty"><a href="#4-empty" class="headerlink" title="4. empty()"></a>4. empty()</h4><p>&emsp;&emsp;empty() 检测优先队列是否为空，返回 true 则空，返回false 则非空。时间复杂度为 O(1)。</p><p>&emsp;&emsp;示例如下：</p><pre><code>#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;int main() {    priority_queue&lt;int&gt; q;    if(q.empty() == true) { // 一开始优先队列内没有元素，所以是空        cout &lt;&lt; &quot;Empty\n&quot;;    } else {        cout &lt;&lt; &quot;Not Empty\n&quot;;    }    q.push(1);    if(q.empty() == true) { // 一开始优先队列内没有元素，所以是空        cout &lt;&lt; &quot;Empty\n&quot;;    } else {        cout &lt;&lt; &quot;Not Empty\n&quot;;    }    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>EmptyNot Empty</code></pre><h4 id="5-size"><a href="#5-size" class="headerlink" title="(5) size()"></a>(5) size()</h4><p>&emsp;&emsp;size() 返回优先队列内元素的个数，时间复杂度为 O(1)。</p><p>&emsp;&emsp;示例如下：</p><pre><code>#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;int main() {    priority_queue&lt;int&gt; q;    q.push(3);    q.push(4);    q.push(1);    cout &lt;&lt; q.size();    return 0;}</code></pre><p>&emsp;&emsp;示例如下：</p><pre><code>3</code></pre><h3 id="4-priority-queue-内元素优先级的设置"><a href="#4-priority-queue-内元素优先级的设置" class="headerlink" title="4. priority_queue 内元素优先级的设置"></a>4. priority_queue 内元素优先级的设置</h3><h4 id="1-基本数据类型的优先级设置"><a href="#1-基本数据类型的优先级设置" class="headerlink" title="(1) 基本数据类型的优先级设置"></a>(1) 基本数据类型的优先级设置</h4><p>&emsp;&emsp;此处指的基本数据类型就是 int型，double型，char型等可以直接使用的数据类型，优先队列对他们的优先级设置一般是数字大的优先级高，因此队首元素就是优先队列内元素最大的哪个(如果 char型，则是字典序最大的)。对基本数据类型来说，下面两种优先队列的定义是等价的(以 int型为例，注意最后两个 &gt; 之间有一个空格)：</p><pre><code>priority_queue&lt;int&gt; q;priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; q;</code></pre><p>&emsp;&emsp;可以发现，第二种定义方式的尖括号内多了两个参数：一个是 vector<int>，另一个是 less<int>。其中 vector<int> (也就是第二个参数)填写的是来承载底层数据结构 <strong>堆(heap)</strong> 的容器，如果第一个参数是 double型或 char型，则此处只需要填写 vector<double> 或 vector<double>；而第三个参数 less<int> 则是对第一个参数的比较类，<strong>less<int> 表示数字大的优先级越大，而 greater<int> 表示数字小的优先级越大。</strong></p><p>&emsp;&emsp;因此，如果想让优先队列总是把最小的元素放在队首，只需要进行如下定义：</p><pre><code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q;</code></pre><p>&emsp;&emsp;下面是一个示例：</p><pre><code>#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;int main() {    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q;    q.push(3);    q.push(4);    q.push(1);    cout &lt;&lt; q.top();    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>1</code></pre><p>&emsp;&emsp;下面来看结构体的优先级设置方法。</p><h4 id="2-结构体的优先级设置"><a href="#2-结构体的优先级设置" class="headerlink" title="(2) 结构体的优先级设置"></a>(2) 结构体的优先级设置</h4><p>&emsp;&emsp;开头举了一个水果的例子，可以对水果的名称和价格建立一个结构体，如下所示：</p><pre><code>struct fruit{    string name;    int price;}</code></pre><p>&emsp;&emsp;现在希望按水果的价格高的为优先级高，就需要重载(overload)小于号 “&lt;”。重载是指对已有的运算符进行重新定义，也就是说，可以改变小于号的功能(例如把他重载为大于号的功能)。</p><pre><code>struct fruit{    string namel;    int price;    friend bool operator &lt; (fruit f1, fruit f2) {        return f1.price &lt; f1.price;    }}</code></pre><p>&emsp;&emsp;可以看到，fruit 结构体中增加了一个函数，其中”friend”为友元，后面的 “bool operator &lt; (fruit f1, fruit f2)” 对 fruit 类型的操作符 “&lt;” 进行了重载(<strong>重载大于号会报错，一位从数学上来说只需要重载小于号，即 f1 &gt; f2，等价于判断 f2 &lt; f1，而 f1 == f2 则等价于判断 !(f1 &lt; f2) &amp;&amp; !(f2 &lt; f1)</strong>)，函数内部为 “return f1.price &lt; f2.price”，因此重载后小于号还是小于号的作用。此时就可以直接定义 fruit 类型的优先队列，其内部就是以价格高的水果为优先级高，如下所示：</p><pre><code>priority_queue&lt;fruit&gt; q;</code></pre><p>&emsp;&emsp;同理，如果想要以价格低的水果为优先级高，那么只需要把 return 中的小于号改为大于号，如下所示：</p><pre><code>struct fruit {    string name;    int price;    friend bool operator &lt; (fruit f1, fruit f2) {        return f1.price &gt; f2.price;    }}</code></pre><p>&emsp;&emsp;示例如下：</p><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;queue&gt;using namespace std;struct fruit {    string name;    int price;    friend bool operator &lt; (fruit f1, fruit f2) {        return f1.price &gt; f2.price;    }}f1, f2, f3;int main() {    priority_queue&lt;fruit&gt; q;    f1.name = &quot;桃子&quot;;    f1.price = 3;    f2.name = &quot;李子&quot;;    f2.price = 4;    f3.name = &quot;苹果&quot;;    f3.price = 1;    q.push(f1);    q.push(f2);    q.push(f3);    cout &lt;&lt; q.top().name &lt;&lt; &quot; &quot; &lt;&lt; q.top().price &lt;&lt; endl;    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>苹果 1</code></pre><p>&emsp;&emsp;<strong>优先队列的比较函数与 sort 中的 cmp 函数的效果是相反的。</strong></p><p>&emsp;&emsp;也可以将比较函数写在外面，只需要把 friend 去掉，把小于号改成一对小括号，然后把重载的函数卸载结构体外面，同时将其用 <strong>struct</strong>包装起来，如下所示：(请注意比较)</p><pre><code>struct cmp {    bool operator () (fruit f1, fruit f2) {        return f1.price &gt; f2.price;    }};</code></pre><p>&emsp;&emsp;这种情况下，需要用之前讲解的第二种定义方式来定义优先队列：</p><pre><code>priority_queue&lt;fruit, vector&lt;fruit&gt;, cmp &gt; q;</code></pre><p>&emsp;&emsp;可以看到，此处只是把 greater&lt;&gt;/less&lt;&gt; 部分换成了 cmp，示例如下：</p><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;queue&gt;using namespace std;struct fruit {    string name;    int price;}f1, f2, f3;struct cmp {    bool operator () (fruit f1, fruit f2) {        return f1.price &gt; f2.price;    }};int main() {    priority_queue&lt;fruit, vector&lt;fruit&gt;, cmp &gt; q;    f1.name = &quot;桃子&quot;;    f1.price = 3;    f2.name = &quot;李子&quot;;    f2.price = 4;    f3.name = &quot;苹果&quot;;    f3.price = 1;    q.push(f1);    q.push(f2);    q.push(f3);    cout &lt;&lt; q.top().name &lt;&lt; &quot; &quot; &lt;&lt; q.top().price &lt;&lt; endl;    return 0;}</code></pre><p>&emsp;&emsp; 最后指出，如果结构体内的数据较为庞大，<strong>建议使用引用来提高效率，</strong>此时比较类的参数中需要加上 “const” 和 “&amp;”，如下所示：</p><pre><code>friend bool operator &lt; (const fruit &amp;f1, const fruit &amp;f2) {    return f1.price &gt; f2.price;}bool operator () (const fruit &amp;f1, const fruit &amp;f2) {    return f1.price &gt; f2.price;}</code></pre><h3 id="5-priority-queue-的常见用途"><a href="#5-priority-queue-的常见用途" class="headerlink" title="5. priority_queue 的常见用途"></a>5. priority_queue 的常见用途</h3><p>&emsp;&emsp;priority_queue可以解决一些贪问题，也可以对 Dijkstra算法进行优化(因为优先队列的本质为堆)。</p><p>&emsp;&emsp;还需要注意，<strong>使用 top() 函数前， 必须用 empty()  判断优先队列是否为空</strong>，否则可能因为队空而出现错误。</p><p>&emsp;&emsp;晚安。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> Markdown </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++标准模板库(STL)</title>
      <link href="/2019/11/17/queue/"/>
      <url>/2019/11/17/queue/</url>
      
        <content type="html"><![CDATA[<h2 id="C-标准模板块-STL-介绍"><a href="#C-标准模板块-STL-介绍" class="headerlink" title="C++标准模板块(STL)介绍"></a>C++标准模板块(STL)介绍</h2><h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h2><p>&emsp;&emsp;queue 翻译为队列，在 <strong>STL</strong> 中主要是实现了一个先进先出的容器。</p><h3 id="1-queue-的定义"><a href="#1-queue-的定义" class="headerlink" title="1. queue 的定义"></a>1. queue 的定义</h3><pre><code>queue&lt;typename&gt; name;</code></pre><h3 id="2-queue-容器内元素的访问"><a href="#2-queue-容器内元素的访问" class="headerlink" title="2. queue 容器内元素的访问"></a>2. queue 容器内元素的访问</h3><p>&emsp;&emsp;由于队列(queue)本身就是一种先进先出的限制性数据结构，因此在 STL 中<strong>只能通过 front() 来访问队首元素，或是通过 back() 来访问队尾元素</strong>。</p><p>&emsp;&emsp;示例如下：</p><pre><code>#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;int main() {    queue&lt;int&gt; q;    for(int i = 1; i &lt;= 5; i++) {        q.push(i);    //push(i) 用以将 i 压入队列，因此依此入队 1 2 3 4 5    }    cout &lt;&lt; q.front() &lt;&lt; &quot; &quot; &lt;&lt; q.back();    // 输出结果 1 5    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>1 5</code></pre><h3 id="3-queue-常用的函数示例解析"><a href="#3-queue-常用的函数示例解析" class="headerlink" title="3. queue 常用的函数示例解析"></a>3. queue 常用的函数示例解析</h3><h4 id="1-push"><a href="#1-push" class="headerlink" title="(1) push()"></a>(1) push()</h4><p>&emsp;&emsp;push(x) 将 x 进行入队，时间复杂度为 O(1)。</p><h4 id="2-front-back"><a href="#2-front-back" class="headerlink" title="(2) front(), back()"></a>(2) front(), back()</h4><p>&emsp;&emsp;front() 和 back() 分别获得队首元素和队尾元素，时间复杂度为 O(1)。</p><h4 id="3-pop"><a href="#3-pop" class="headerlink" title="(3) pop()"></a>(3) pop()</h4><p>&emsp;&emsp;pop() 令队首元素出队，时间复杂度为 O(1)</p><p>&emsp;&emsp;示例如下：</p><pre><code>#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;int main() {    queue&lt;int&gt; q;    for(int i = 1; i &lt;= 5; i++) {        q.push(i);    //push(i) 用以将 i 压入队列，因此依此入队 1 2 3 4 5    }    for(int i = 1; i &lt;= 3; i++) {        q.pop(); //出队首元素三次(即依此出队 1 2 3)；    }    cout &lt;&lt; q.front();    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>4</code></pre><h4 id="4-empty"><a href="#4-empty" class="headerlink" title="(4) empty()"></a>(4) empty()</h4><p>&emsp;&emsp;empty() 检测 queue 是否为空，返回 true 为空，返回 false 则非空。时间复杂度为 O(1)。</p><p>&emsp;&emsp;示例如下：</p><pre><code>#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;int main() {    queue&lt;int&gt; q;    if(q.empty() == true) {    // 一开始队列内没有元素，所以为空        cout &lt;&lt; &quot;Empty\n&quot;;    } else {        cout &lt;&lt; &quot;Not Empty\n&quot;;    }    q.push(1);    if(q.empty() == true) {// 在入队 &quot;1&quot;后，队列非空        cout &lt;&lt; &quot;Empty\n&quot;;    } else {        cout &lt;&lt; &quot;Not Empty\n&quot;;    }    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>EmptyNot Empty</code></pre><h4 id="5-size"><a href="#5-size" class="headerlink" title="(5) size()"></a>(5) size()</h4><p>&emsp;&emsp;size()返回 queue 内元素的个数，时间复杂度为 O(1)。</p><p>&emsp;&emsp;示例如下：</p><pre><code>#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;int main() {    queue&lt;int&gt; q;    for(int i = 1; i &lt;= 5; i++) {        q.push(i);    }    cout &lt;&lt; q.size();    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>5</code></pre><h3 id="4-queue-的常见用途"><a href="#4-queue-的常见用途" class="headerlink" title="4. queue 的常见用途"></a>4. queue 的常见用途</h3><p>&emsp;&emsp;当需要实现广度优先搜索时，可以不用手动实现一个队列，而是用 queue 作为代替，以提高程序的准确性。</p><p>&emsp;&emsp;另外有一点注意的是：<strong>使用 front() 和 pop() 函数前，必须用 empty() 判断队列是否为空</strong>，否则可能因为队空而出现异常。</p><p>&emsp;&emsp;晚安。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> Markdown </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++标准模板库(STL)</title>
      <link href="/2019/11/17/map/"/>
      <url>/2019/11/17/map/</url>
      
        <content type="html"><![CDATA[<h2 id="C-标准模板块-STL-介绍"><a href="#C-标准模板块-STL-介绍" class="headerlink" title="C++标准模板块(STL)介绍"></a>C++标准模板块(STL)介绍</h2><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>&emsp;&emsp;map翻译为映射，也是常用的 <strong>STL</strong> 容器。从所周知，在定义数组时(如 int array[100])，其实就是一个从 int 型到 int型的映射，比如 array[0] = 25，array[4] = 36 就分别是将 0 映射到 25，将 4 映射到 36。一个 double 型数组则是将 int 型映射到 double 型，例如 db[0] = 3.14，db[1] = 0.01。但是，无论是什么类型，它总是将 int型映射到其他类型。这似乎表现出一个弊端：当需要以其他类型作为关键字来做映射时，会显得不太方便。例如有一本字典，上面提供了很多的字符串对应的页码，如果要用数组来表示 “字符串 –&gt; 页码” 这样的对应关系，就会感觉不太友好。这时，我们的map就派上用场了，因为 <strong>map 可以将任何基本类型(包括STL容器)映射到任何基本类型(包括STL容器)</strong>，也就可以建立 string型到 int型的映射了。</p><h3 id="1-map-的定义"><a href="#1-map-的定义" class="headerlink" title="1. map 的定义"></a>1. map 的定义</h3><p>&emsp;&emsp;单独定义一个map：</p><pre><code>map&lt;typenmae, typename&gt; mp;</code></pre><p>&emsp;&emsp;map 和其他 <strong>STL</strong> 容器在定义上有点不一样，因为 map 需要确定映射前类型(键：key)和映射后类型(值：value)，所以需要在 &lt;&gt; 内填写两个类型，其中第一个是键的类型，第二个是值的类型。如果是 int型 映射到 int型，就是相当于是普通的 int数组。</p><p>&emsp;&emsp;而如果是字符串到整型的映射，<strong>必须使用 string 而不能用 char数组</strong>：</p><pre><code>map&lt;string, int&gt; mp;</code></pre><p>&emsp;&emsp;这是因为 char 数组作为数组，是不能被作为键值的，如果想用字符串做映射，必须用 string</p><p>&emsp;&emsp;前面也说到，map 的键和值也可以是 <strong>STL</strong> 容器，例如可以将一个 set容器映射到一个字符串：</p><pre><code>map&lt;set&lt;int&gt;, string&gt; mp;</code></pre><h3 id="2-map-容器内元素的访问"><a href="#2-map-容器内元素的访问" class="headerlink" title="2. map 容器内元素的访问"></a>2. map 容器内元素的访问</h3><p>&emsp;&emsp;map 一般有两种访问方式：通过下标访问或者通过迭代器访问。</p><h4 id="1-通过下标访问"><a href="#1-通过下标访问" class="headerlink" title="(1) 通过下标访问"></a>(1) 通过下标访问</h4><p>&emsp;&emsp;和访问普通的数组是一样的，例如对一个定义为 map&lt;char, int&gt; mp 的map来说，就可以直接使用 mp[‘c’] 的方式来访问它对应的整数。于是，当建立映射时，就可以直接使用 mp[‘c’] = 20，这样普通数组一样的方式。但是要注意的是，<strong>map中的键是唯一的</strong>，也就是说，下面的代码将输出 30：</p><pre><code>#include&lt;iostream&gt;#include&lt;map&gt;using namespace std;int main() {    map&lt;char, int&gt; mp;    mp[&#39;c&#39;] = 20;    mp[&#39;c&#39;] = 30;    // 20 被覆盖cout &lt;&lt; mp[&#39;c&#39;];    return 0;}</code></pre><h4 id="2-通过迭代器访问"><a href="#2-通过迭代器访问" class="headerlink" title="(2) 通过迭代器访问"></a>(2) 通过迭代器访问</h4><p>&emsp;&emsp;map 迭代器的定义和其他 <strong>STL</strong> 容器迭代器定义的方式相同：</p><pre><code>map&lt;typename1, typename2&gt;::iterator it;</code></pre><p>&emsp;&emsp;typename1 和 typename2 就是定义 map时填写的类型，这样就得到了迭代器it。</p><p>&emsp;&emsp;map 迭代器的使用方式和其他 <strong>STL</strong>容器的迭代器不同，因为 map 的每一对映射都有两个typename，这决定了必须能通过一个 it 来同时访问键和值。事实上，<strong>map 可以使用 it-&gt;first来访问键，使用 it-&gt;second 来访问值</strong>。</p><p>&emsp;&emsp;来看下面这个示例：</p><pre><code>#include&lt;iostream&gt;#include&lt;map&gt;using namespace std;int main() {    map&lt;char, int&gt; mp;    mp[&#39;m&#39;] = 20;    mp[&#39;r&#39;] = 30;    mp[&#39;a&#39;] = 40;    for(map&lt;char, int&gt;::iterator it = mp.begin(); it != mp.end(); it++){        cout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;    }    return 0;}</code></pre><p>&emsp;&emsp;在上面这个例子中，it-&gt;first 是当前映射的键，it-&gt;second 是当前映射的值。程序的输出如下：</p><pre><code>a 40m 20r 30</code></pre><p>&emsp;&emsp;接下来似乎发现了一个很有意思的现象，<strong>map会以键从小到大的顺序自动排序，</strong>即按 a &lt; m &lt; r 的顺序排序这三对映射。这是由于 map 内部是使用红黑树实现的(set 也是)，在建立映射的过程中会自动实现从小到大的排序功能。</p><h3 id="map-常用函数实例解析"><a href="#map-常用函数实例解析" class="headerlink" title="map 常用函数实例解析"></a>map 常用函数实例解析</h3><h4 id="1-find"><a href="#1-find" class="headerlink" title="(1) find()"></a>(1) find()</h4><p>&emsp;&emsp;find(key) 返回键为 key 的映射的迭代器，时间复杂度为 O(logN)，N 为 map 中映射的个数。示例如下：</p><pre><code>#include&lt;iostream&gt;#include&lt;map&gt;using namespace std;int main() {    map&lt;char, int&gt; mp;    mp[&#39;a&#39;] = 1;    mp[&#39;b&#39;] = 2;    mp[&#39;c&#39;] = 3;    map&lt;char, int&gt;::iterator it = mp.find(&#39;b&#39;);    cout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>b 2</code></pre><h4 id="2-erase"><a href="#2-erase" class="headerlink" title="(2) erase()"></a>(2) erase()</h4><p>&emsp;&emsp;erase() 有两种方法：删除单个元素，删除一个区间内的所有元素。</p><p>&emsp;&emsp;① 删除单个元素。</p><p>&emsp;&emsp;删除单个元素有两种方法：</p><ul><li>mp.erase(it)，it 为需要删除的元素的迭代器。时间复杂度为 O(1)。</li></ul><p>&emsp;&emsp;示例如下：</p><pre><code>#include&lt;iostream&gt;#include&lt;map&gt;using namespace std;int main() {    map&lt;char, int&gt; mp;    mp[&#39;a&#39;] = 1;    mp[&#39;b&#39;] = 2;    mp[&#39;c&#39;] = 3;    map&lt;char, int&gt;::iterator it = mp.find(&#39;b&#39;);    mp.erase(it);    // 删除 b 2    for(map&lt;char, int&gt;::iterator it = mp.begin(); it != mp.end(); it++) {        cout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;    }    return 0;}</code></pre><p>&emsp;&emsp;输出内容如下：</p><pre><code>a 1c 3</code></pre><p>&emsp;&emsp;② 删除一个区间内的所有元素。</p><p>&emsp;&emsp;mp.erase(first, last)，其中 first 为需要删除的区间的起始迭代器，而 last 则为需要删除的区间的末尾的迭代器的下一个地址，也即为删除左闭右开的区间[first, second)。时间复杂度为 O(last - first)。</p><p>&emsp;&emsp;示例如下：</p><pre><code>#include&lt;iostream&gt;#include&lt;map&gt;using namespace std;int main() {    map&lt;char, int&gt; mp;    mp[&#39;a&#39;] = 1;    mp[&#39;b&#39;] = 2;    mp[&#39;c&#39;] = 3;    map&lt;char, int&gt;::iterator it = mp.find(&#39;b&#39;);    // 令 it 指向键为 b 的映射    mp.erase(it, mp.end());    // 删除 it 之后的所有映射，即 b 2 和 c 3    for(map&lt;char, int&gt;::iterator it = mp.begin(); it != mp.end(); it++) {        cout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;    }    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>a 1</code></pre><h4 id="3-size"><a href="#3-size" class="headerlink" title="(3) size()"></a>(3) size()</h4><p>&emsp;&emsp;size() 用来获得 map 中映射的对数，时间复杂度为 O(1)。</p><p>&emsp;&emsp;示例如下：</p><pre><code>#include&lt;iostream&gt;#include&lt;map&gt;using namespace std;int main() {    map&lt;char, int&gt; mp;    mp[&#39;a&#39;] = 1;    mp[&#39;b&#39;] = 2;    mp[&#39;c&#39;] = 3;    cout &lt;&lt; mp.size() &lt;&lt; endl;    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>3</code></pre><h4 id="4-clear"><a href="#4-clear" class="headerlink" title="(4) clear()"></a>(4) clear()</h4><p>&emsp;&emsp;clear() 用来清空 map 中的所有元素，复杂度为 O(N)，其中 N 为 map 中元素的个数。</p><p>&emsp;&emsp;示例如下：</p><pre><code>#include&lt;iostream&gt;#include&lt;map&gt;using namespace std;int main() {    map&lt;char, int&gt; mp;    mp[&#39;a&#39;] = 1;    mp[&#39;b&#39;] = 2;    mp.clear();    cout &lt;&lt; mp.size() &lt;&lt; endl;    return 0;}</code></pre><h3 id="map-的常见的用途"><a href="#map-的常见的用途" class="headerlink" title="map 的常见的用途"></a>map 的常见的用途</h3><p>&emsp;&emsp;① 需要建立字符(或字符串) 与整数之间的映射的题目，使用 map 可以减少代码量。</p><p>&emsp;&emsp;② 判断大整数或者其他类型数据是否存在的题目，可以把 map 当 bool 数组用。</p><p>&emsp;&emsp;③ 字符串和字符串的映射也有可能会遇到。</p><p>&emsp;&emsp;延伸：map 的键和值是唯一的，而如果一个键需要对应多个值，就只能用 <strong>multimap</strong>。</p><p>&emsp;&emsp;晚安。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> Markdown </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++标准模板库(STL)</title>
      <link href="/2019/11/16/string/"/>
      <url>/2019/11/16/string/</url>
      
        <content type="html"><![CDATA[<h2 id="C-标准模板块-STL-介绍"><a href="#C-标准模板块-STL-介绍" class="headerlink" title="C++标准模板块(STL)介绍"></a>C++标准模板块(STL)介绍</h2><h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><p>&emsp;&emsp;在C语言中，一般使用字符数组char str[] 来存放字符串，但是使用字符数组有时会显得操作麻烦，而且容易因经验不足而产生一些错误。为了使编程者可以更方便地对字符串进行操作，C++ 在 <strong>STL</strong> 中加入了 string 类型，对字符串常用的需求功能进行了封装，使得操作起来更方便，且不易出错。</p><h3 id="1-string-的定义"><a href="#1-string-的定义" class="headerlink" title="1. string 的定义"></a>1. string 的定义</h3><p>&emsp;&emsp;定义 string 的方式跟基本数据类型相同，只需要在 string 后跟上变量名即可：</p><pre><code>string str;</code></pre><p>&emsp;&emsp;如果要初始化，可以直接给 string 类型的变量进行赋值：</p><pre><code>string str = &quot;abcd&quot;;</code></pre><h3 id="2-string-中内容的访问"><a href="#2-string-中内容的访问" class="headerlink" title="2. string 中内容的访问"></a>2. string 中内容的访问</h3><h4 id="1-通过下标访问"><a href="#1-通过下标访问" class="headerlink" title="(1) 通过下标访问"></a>(1) 通过下标访问</h4><p>&emsp;&emsp;一般来说，可以直接向字符数组那样去访问 string：</p><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main() {    string str = &quot;abcd&quot;;    for(int i = 0; i &lt; str.length(); i++) {        cout &lt;&lt; str[i] &lt;&lt; &quot; &quot;;    }    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>a b c d</code></pre><p>&emsp;&emsp;如果要读入和输出整个字符串，则<strong>只能用cin 和 cout</strong>，我们可以使用 <strong>c_str()</strong> 将 string 类型转换为字符数组进行输出，示例如下：</p><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main() {    string str;    cin &gt;&gt; str;    cout &lt;&lt; str;    printf(&quot;%s&quot;,str.c_str());    return 0;}</code></pre><h4 id="2-通过迭代器访问"><a href="#2-通过迭代器访问" class="headerlink" title="(2) 通过迭代器访问"></a>(2) 通过迭代器访问</h4><p>&emsp;&emsp;一般通过 (1) 即可满足访问的要求，但是有些函数比如 insert() 和 erase() 则要求以迭代器为参数。</p><p>&emsp;&emsp;由于 string 不向其他 <strong>STL</strong> 容器那样需要参数，因此可以直接如下定义：</p><pre><code>string::iterator it;</code></pre><p>&emsp;&emsp; 这样就得到了迭代器 it，并且可以通过 *it 来访问 string 里的每一位：</p><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main() {    string str = &quot;abcd&quot;;    for(string::iterator it = str.begin(); it != str.end(); it++) {        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    }    cout &lt;&lt; *(str.begin() + 1);    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>a b c d b</code></pre><p>&emsp;&emsp;最后指出，<strong>string 和 vector一样，支持直接对迭代器进行加减某个数字</strong>，如 str.begin() + 3。</p><h3 id="3-string-常用的函数实例解析"><a href="#3-string-常用的函数实例解析" class="headerlink" title="3. string 常用的函数实例解析"></a>3. string 常用的函数实例解析</h3><p>&emsp;&emsp;事实上，string 的函数有很多，但是有些函数并不常用，因此下面就几个常用的函数举例。</p><h4 id="1-operator"><a href="#1-operator" class="headerlink" title="(1) operator+="></a>(1) operator+=</h4><p>&emsp;&emsp;这是 string 的加法，可以将两个或多个 string 拼接在一起。</p><p>&emsp;&emsp;示例如下：</p><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main() {    string str1 = &quot;abc&quot;, str2 = &quot;xyz&quot;, str3 = &quot;qwe&quot;, str4;    str4 = str1 + str2 + str3;    str1 += str2;    cout &lt;&lt; str4 &lt;&lt; endl;    cout &lt;&lt; str1 &lt;&lt; endl;    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>abcxyzqweabcxyz</code></pre><h4 id="2-compare-operator"><a href="#2-compare-operator" class="headerlink" title="(2) compare operator"></a>(2) compare operator</h4><p>&emsp;&emsp;两个 string 类型可以直接使用 ==, !=, &lt;, &lt;=, &gt;, &gt;= 比较大小，比较规则是<strong>字典序</strong>。</p><p>&emsp;&emsp;示例如下：</p><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main() {    string str1 = &quot;aa&quot;, str2 = &quot;aaa&quot;, str3 = &quot;abc&quot;, str4 = &quot;xyz&quot;;    if(str1 &lt; str2) cout &lt;&lt; &quot;ok1!\n&quot;;    if(str1 != str3) cout &lt;&lt; &quot;ok2!\n&quot;;    if(str1 4= str3) cout &lt;&lt; &quot;ok3!\n&quot;;    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>ok1ok2ok2</code></pre><h4 id="3-length-size"><a href="#3-length-size" class="headerlink" title="(3) length()/size()"></a>(3) length()/size()</h4><p>&emsp;&emsp;length()返回 string 的长度，即存放的字符数，时间复杂度为 O(1)。size() 与 length() 基本相同。</p><p>&emsp;&emsp;示例如下：</p><pre><code>string str = &quot;abcxyz&quot;;cout &lt;&lt; str.length() &lt;&lt; &quot; &quot; &lt;&lt; str.size();</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>6 6</code></pre><h4 id="4-insert"><a href="#4-insert" class="headerlink" title="(4) insert()"></a>(4) insert()</h4><p>&emsp;&emsp;string 的 insert() 函数有很多写法，这里给出几个常用的写法，时间复杂度为 O(N)。</p><p>&emsp;&emsp;① insert(pos, string)，在 pos 号位置插入字符串string。</p><p>&emsp;&emsp;示例如下：</p><pre><code>string str = &quot;abcxyz&quot;, str2 = &quot;opg&quot;;str.insert(3, str);    // 往str[3] 处位置插入 &quot;opg&quot;，这里 str2 的位置直接写&quot;opg&quot;也可以。cout &lt;&lt; str &lt;&lt; endl;</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>abcopgxyz</code></pre><p>&emsp;&emsp;② insert(it, it2, it3)，it 为原字符的欲插入位置，it2 和 it3 为待插字符的首尾迭代器，用来表示串 [it2, it3) 将被插入在 it 的位置上。</p><p>&emsp;&emsp;示例如下：</p><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main() {    string str1 = &quot;abcde&quot;, str2 = &quot;fghijk&quot;;    str1.insert(str1.begin() + 3, str2.begin(), str2.end() - 1);    // 这三个参数，必须都是迭代器。    cout &lt;&lt; str1 &lt;&lt; endl;    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>abcfghijde</code></pre><h4 id="5-erase"><a href="#5-erase" class="headerlink" title="(5) erase()"></a>(5) erase()</h4><p>&emsp;&emsp;erase()有两种写法：删除单个元素，删除一个区间内的所有元素。时间复杂度均为 O(N)。</p><p>&emsp;&emsp;① 删除单个元素。</p><p>&emsp;&emsp;str.erase(it) 用于删除单个元素，it为需要删除的元素的迭代器。</p><p>&emsp;&emsp;示例如下：</p><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main() {    string str = &quot;abcdefg&quot;;    str.erase(str.begin() + 4);    // 删除 4 号位。    cout &lt;&lt; str &lt;&lt; endl;    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>abcdfg</code></pre><p>&emsp;&emsp;② 删除一个区间内的所有元素。</p><p>&emsp;&emsp;删除一个区间内所有的元素有两种方法：</p><ul><li>str.erase(first,last)，其中 first 为需要删除的区间的起始迭代器，而 last 则为需要删除的区间的末尾迭代器的下一个地址，也即为删除[first, last)。</li></ul><p>&emsp;&emsp;示例如下：</p><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main() {    string str = &quot;abcdefg&quot;;    // 删除在 [str.begin() + 2, str.end() - 1) 内的元素，即cdef    str.erase(str.begin() + 2, str.end() - 1);    cout &lt;&lt; str &lt;&lt; endl;    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>abg</code></pre><ul><li>str.erase(pos, length)，其中 pos 为需要开始删除的起始位置，length 为删除的字符个数。</li></ul><p>&emsp;&emsp;示例如下：</p><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main() {    string str = &quot;abcdefg&quot;;    str.erase(3, 2);    // 删除从 3号位开始的2个字符，即 de    cout &lt;&lt; str &lt;&lt; endl;    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>abcfg</code></pre><h4 id="6-clear"><a href="#6-clear" class="headerlink" title="(6) clear()"></a>(6) clear()</h4><p>&emsp;&emsp;clear() 用以清空 string 中的数据，时间复杂度为 O(1)。</p><p>&emsp;&emsp;示例如下：</p><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main() {    string str = &quot;abcd&quot;;    str.clear();    // 清空字符串    cout &lt;&lt; str.size();    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>0</code></pre><h4 id="7-substr"><a href="#7-substr" class="headerlink" title="(7) substr()"></a>(7) substr()</h4><p>&emsp;&emsp;substr(pos, length) 返回从 pos 号位开始，长度为 length 的字串，时间复杂度为 O(1)。</p><p>&emsp;&emsp;示例如下：</p><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main() {    string str = &quot;Thanks for your smile.&quot;;    cout &lt;&lt; str.substr(0, 6) &lt;&lt; endl;    cout &lt;&lt; str.substr(11, 4) &lt;&lt; endl;    cout &lt;&lt; str.substr(16, 5) &lt;&lt; endl;    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>Thanksyoursmile</code></pre><h4 id="8-string-npos"><a href="#8-string-npos" class="headerlink" title="(8) string::npos"></a>(8) string::npos</h4><p>&emsp;&emsp;string::npos 是一个常数，其本身的值为 -1，但是由于是 unsigned_int 类型，因此实际上也可以认为是 unsigned_int 类型的最大值。<strong>string_npos 用以作为 find函数失配时的返回值</strong>。可以认为string::npos 等于 -1 或者 4294967295。</p><p>&emsp;&emsp;示例如下：</p><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main() {    if(string::npos == -1)        cout &lt;&lt; &quot;-1 is true.&quot; &lt;&lt; endl;    if(string::npos == 4294967295)        cout &lt;&lt; &quot;4294967295 is also true.&quot; &lt;&lt; endl;    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>-1 is true.4294967295 is also true.</code></pre><h4 id="9-find"><a href="#9-find" class="headerlink" title="(9) find()"></a>(9) find()</h4><p>&emsp;&emsp;str.find(str2)，当 str2 是 str 的字串时，返回其在 str 第一次出现的位置；如果 str2 不是 str 的字串，那么返回string::npos。</p><p>&emsp;&emsp;str.find(str2,pos)，从 str 的 pos 号开始匹配 str2，返回值与上相同。</p><p>&emsp;&emsp;时间复杂度为 O(nm)，其中 n 和 m 分别为 str 和 str2 的长度。</p><p>&emsp;&emsp;示例如下：</p><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main() {    string str = &quot;Thank you for your smile.&quot;;    string str2 = &quot;you&quot;;    string str3 = &quot;me&quot;;    if(str.find(str2) != string::npos) {        cout &lt;&lt; str.find(str2) &lt;&lt; endl;    }    if(str.find(str2, 7) != string::npos) {        cout &lt;&lt; str.find(str2, 7) &lt;&lt; endl;    }    if(str.find(str3) != string::npos) {        cout &lt;&lt; str.find(str3) &lt;&lt; endl;    } else {        cout &lt;&lt; &quot;I know there is no position for me.&quot; &lt;&lt; endl;    }    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>614I know there is no position for me.</code></pre><h4 id="10-replace"><a href="#10-replace" class="headerlink" title="(10) replace()"></a>(10) replace()</h4><p>&emsp;&emsp;str.replace(pos, len, str2) 把 str 从 pos 号为开始，长度为 len 的字串替换为 str2。</p><p>&emsp;&emsp;str.replace(it1, it2, str2) 把 str 的迭代器 [it1, it2) 范围的字串替换为 str2。</p><p>&emsp;&emsp;时间复杂度为O(str.length())。</p><p>&emsp;&emsp;示例如下：</p><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main() {    string str = &quot;Maybe you will turn around.&quot;;    string str2 = &quot;will not&quot;;    string str3 = &quot;Surely&quot;;    cout &lt;&lt; str.replace(10, 4, str2) &lt;&lt; endl;    cout &lt;&lt; str.replace(str.begin(), str.begin() + 5, str3) &lt;&lt; endl;    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>Maybe you will not turn around.Surely you will not turn around.</code></pre><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="PTA-A1006-Are-They-Equal"><a href="#PTA-A1006-Are-They-Equal" class="headerlink" title="[PTA A1006] Are They Equal"></a>[PTA A1006] Are They Equal</h3><p>If a machine can save only 3 significant digits, the float numbers 12300 and 12358.9 are considered equal since they are both saved as 0.123×10^5 with simple chopping. Now given the number of significant digits on a machine and two float numbers, you are supposed to tell if they are treated equal in that machine.</p><p><strong>Input Specification:</strong></p><p>Each input file contains one test case which gives three numbers N, A and B, where N (&lt;100) is the number of significant digits, and A and B are the two float numbers to be compared. Each float number is non-negative, no greater than 10^100, and that its total digit number is less than 100.</p><p><strong>Output Specification:</strong></p><p>For each test case, print in a line YES if the two numbers are treated equal, and then the number in the standard form 0.d[1]…d[N]*10^k (d[1]&gt;0 unless the number is 0); or NO if they are not treated equal, and then the two numbers in their standard form. All the terms must be separated by a space, with no extra space at the end of a line.</p><p>Note: Simple chopping is assumed without rounding.</p><p><strong>Sample Input 1:</strong></p><p>3 12300 12358.9</p><p><strong>Sample Output 1:</strong></p><p>YES 0.123*10^5</p><p><strong>Sample Input 2:</strong></p><p>3 120 128</p><p><strong>Sample Output 2:</strong></p><p>NO 0.120<em>10^3 0.128</em>10^3</p><p>思路分析：</p><p>获取科学计数法的 主体 和 指数部分，然后分两种情况考虑：</p><pre><code>① 0.a1a2a3a4···② b1b2···bm.a1a2a3···</code></pre><p>代码如下：</p><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int n = 0; // 有效的位数 // 求出 主体 和 指数 string fun(string s, int &amp;e) {    int k = 0;    //  删除前导的 0    while(s.length() &gt; 0 &amp;&amp; s[0] == &#39;0&#39;) {        s.erase(s.begin());    }    // 判断 s 大于 1 还是 小于1    if(s[0] == &#39;.&#39;) {    //如果去掉前导 0 是 . 说明小于 1         s.erase(s.begin());    // 删除 .         while(s.length() &gt; 0 &amp;&amp; s[0] == &#39;0&#39;) {            s.erase(s.begin());    // 去掉小数点后的 0            e--;    // 去掉一个 0 ，指数 e--         }    } else {        // 否则 s 大于 0        while(k &lt; s.length() &amp;&amp; s[k] != &#39;.&#39;) { // 寻找小数点             k++;            e++;    //指数 e++         }        if(s[k] == &#39;.&#39;) {            s.erase(s.begin() + k);    // 删除小数点         }    }    // 如果去掉前导 0 长度为 0 说明这个数为 0       if(s.length() == 0) {        e = 0;    }    int num = 0;    k = 0;    string res;     // 下一步 根据 有效位数，来确定主体。    while(num &lt; n) {        if(k &lt; s.length()) res += s[k++];        else res += &quot;0&quot;;        num++;    }    return res;}int main() {    string s1, s2, s3, s4;    cin &gt;&gt; n &gt;&gt; s1 &gt;&gt; s2;    int e1 = 0, e2 = 0;    s3 = fun(s1, e1);     s4 = fun(s2, e2);    if(s3 == s4 &amp;&amp; e1 == e2) {        cout &lt;&lt; &quot;YES 0.&quot; &lt;&lt; s3 &lt;&lt; &quot;*10^&quot; &lt;&lt; e1 &lt;&lt; endl;    } else {        cout &lt;&lt; &quot;NO 0.&quot; &lt;&lt; s3 &lt;&lt; &quot;*10^&quot; &lt;&lt; e1 &lt;&lt; &quot; 0.&quot; &lt;&lt; s4 &lt;&lt; &quot;*10^&quot; &lt;&lt; e2 &lt;&lt; endl;    }    return 0;}</code></pre><p>&emsp;&emsp;晚安。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> Markdown </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++标准模板库(STL)</title>
      <link href="/2019/11/16/set/"/>
      <url>/2019/11/16/set/</url>
      
        <content type="html"><![CDATA[<h2 id="C-标准模板块-STL-介绍"><a href="#C-标准模板块-STL-介绍" class="headerlink" title="C++标准模板块(STL)介绍"></a>C++标准模板块(STL)介绍</h2><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><h3 id="1-set-的定义"><a href="#1-set-的定义" class="headerlink" title="1. set 的定义"></a>1. set 的定义</h3><h4 id="emsp-emsp-单独定义一个set"><a href="#emsp-emsp-单独定义一个set" class="headerlink" title="&emsp;&emsp;单独定义一个set"></a>&emsp;&emsp;单独定义一个set</h4><pre><code>set&lt;typename&gt; name;set&lt;double&gt; name;set&lt;int&gt; name;set&lt;char&gt; name;set&lt;node&gt; name;    // node 是结构体的类型</code></pre><h4 id="emsp-emsp-set数组的定义和-vector-相同"><a href="#emsp-emsp-set数组的定义和-vector-相同" class="headerlink" title="&emsp;&emsp;set数组的定义和 vector 相同"></a>&emsp;&emsp;set数组的定义和 vector 相同</h4><pre><code>set&lt;typename&gt; st[100];</code></pre><p>&emsp;&emsp;这样 st[0] - st[99] 中每一个都是一个vector容器。</p><h3 id="2-set-容器内元素的访问"><a href="#2-set-容器内元素的访问" class="headerlink" title="2. set 容器内元素的访问"></a>2. set 容器内元素的访问</h3><h4 id="emsp-emsp-set-只能通过迭代器-iterator-访问"><a href="#emsp-emsp-set-只能通过迭代器-iterator-访问" class="headerlink" title="&emsp;&emsp;set 只能通过迭代器(iterator)访问"></a>&emsp;&emsp;set 只能通过迭代器(iterator)访问</h4><pre><code>set&lt;typename&gt;::iterator it;</code></pre><p>&emsp;&emsp;typename 就是定义 set 时填写的类型，下面是 typename 为 int 和 char 的举例：</p><pre><code>set&lt;int&gt;::iterator it;set&lt;char&gt;::iterator it;</code></pre><p>&emsp;&emsp;这样就得到了迭代器it，并且可以通过 *it 来访问 set 里的元素。</p><p>&emsp;&emsp;由于<strong>除开 vector 和 string 之外的 STL 容器都不支持 *(it + i)</strong>的访问方式，因此只能按照以下方式枚举：</p><pre><code>#include&lt;iostream&gt;#include&lt;set&gt;using namespace std;int main() {    set&lt;int&gt; st;    st.insert(3);    // insert(x)将 x 插入 set 中    st.insert(5);    st.insert(2);    st.insert(3);     // 注意，不支持 it &lt; st.end() 的写法    for(set&lt;int&gt;::iterator it = st.begin(); it != st.end(); it++) {        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    }    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>2 3 5</code></pre><h3 id="3-set-常用的函数实例解析"><a href="#3-set-常用的函数实例解析" class="headerlink" title="3. set 常用的函数实例解析"></a>3. set 常用的函数实例解析</h3><h4 id="1-insert"><a href="#1-insert" class="headerlink" title="(1) insert()"></a>(1) insert()</h4><p>&emsp;&emsp;insert(x) 可将 x 插入 set 容器中，并自动递增排序和去重，时间复杂度为 O(logN)，其中 N 为 set 内的元素的个数。</p><h4 id="2-find"><a href="#2-find" class="headerlink" title="(2) find()"></a>(2) find()</h4><p>&emsp;&emsp;find(value) 返回 set 中对应值为 value 的迭代器，时间复杂度为 O(logN)，其中 N 为 set 内的元素的个数。</p><pre><code>#include&lt;iostream&gt;#include&lt;set&gt;using namespace std;int main() {    set&lt;int&gt; st;    for(int i = 1; i &lt;= 3; i++) {        st.insert(i);    }    set&lt;int&gt;::iterator it = st.find(2);    //在 set 中查找2，返回其迭代器    cout &lt;&lt; *it;    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>2</code></pre><h4 id="3-erase"><a href="#3-erase" class="headerlink" title="(3) erase()"></a>(3) erase()</h4><p>&emsp;&emsp;erase()有两种方法：删除单个元素，删除一个区间内的所有元素。</p><p>&emsp;&emsp;① 删除单个元素。</p><p>&emsp;&emsp;删除单个元素的方法：</p><ul><li><p>st.erase(it)，it 为所有需要删除元素的迭代器。时间复杂度为 O(1)。可以结合 find()  函数来使用。示例如下：</p><pre><code>  #include&lt;iostream&gt;  #include&lt;set&gt;  using namespace std;  int main() {      set&lt;int&gt; st;      st.insert(100);      st.insert(200);      st.insert(100);      st.insert(300);          st.erase(st.find(100));    // 利用 find()函数找到100， 然后用 erase 删除它      st.erase(st.find(200));    // 利用 find()函数找到100， 然后用 erase 删除它      for(set&lt;int&gt;::iterator it = st.begin(); it != st.end(); it++) {          cout &lt;&lt; *it;      }      return 0;  }</code></pre></li></ul><p>&emsp;&emsp;输出结果：</p><pre><code>200</code></pre><p>&emsp;&emsp;② 删除一个区间内的所有元素。<br>&emsp;&emsp;st.erase(first, end)可以删除一个区间内的所有元素，其中 first 为所需要删除区间的起始迭代器，而 last 则为所需要删除区间的末尾迭代器的下一个地址，也即为删除[first, last)。时间复杂度为 O(last - first)。示例如下：</p><pre><code>#include&lt;iostream&gt;#include&lt;set&gt;using namespace std;int main() {    set&lt;int&gt; st;    st.insert(20);    st.insert(10);    st.insert(40);    st.insert(30);        set&lt;int&gt;::iterator it  = st.find(30);    st.erase(it, st.end()); // 删除元素 30 至 set 末尾之间的元素，即 30 和 40                for(set&lt;int&gt;::iterator it = st.begin(); it != st.end(); it++) {        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    }    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>3</code></pre><h4 id="4-size"><a href="#4-size" class="headerlink" title="(4) size()"></a>(4) size()</h4><p>&emsp;&emsp;size() 用来获取 set 内元素的个数，时间复杂度为 O(1)。</p><p>&emsp;&emsp;示例如下：</p><pre><code>#include&lt;iostream&gt;#include&lt;set&gt;using namespace std;int main() {    set&lt;int&gt; st;    st.insert(2);    st.insert(5);    st.insert(4);    // 插入 2 5 4    st.clear();        // 输出 set 内元素的个数    cout &lt;&lt; st.size();            return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>3</code></pre><h4 id="5-clear"><a href="#5-clear" class="headerlink" title="(5) clear()"></a>(5) clear()</h4><p>&emsp;&emsp;clear() 用来清空 set 中的所有元素，复杂度为 O(N)，其中 N 为 set 内元素的个数。</p><p>&emsp;&emsp;示例如下：</p><pre><code>#include&lt;iostream&gt;#include&lt;set&gt;using namespace std;int main() {    set&lt;int&gt; st;    st.insert(2);    st.insert(5);    st.insert(4);    st.clear();    // 清空 set    cout &lt;&lt; st.size();            return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>0</code></pre><h3 id="3-set-的常见用途"><a href="#3-set-的常见用途" class="headerlink" title="3. set 的常见用途"></a>3. set 的常见用途</h3><h4 id="emsp-emsp-set-最主要的作用是自动去重并按升序排序，因此碰到需要去重但是却不方便直接开数组的情况，可以尝试用-set-解决。"><a href="#emsp-emsp-set-最主要的作用是自动去重并按升序排序，因此碰到需要去重但是却不方便直接开数组的情况，可以尝试用-set-解决。" class="headerlink" title="&emsp;&emsp;set 最主要的作用是自动去重并按升序排序，因此碰到需要去重但是却不方便直接开数组的情况，可以尝试用 set 解决。"></a>&emsp;&emsp;set 最主要的作用是自动去重并按升序排序，因此碰到需要去重但是却不方便直接开数组的情况，可以尝试用 set 解决。</h4><p>&emsp;&emsp;<strong>延伸</strong>：set 中元素是唯一的，如果需要处理不唯一的情况，则需要使用 <strong>multiset</strong>。</p><p>&emsp;&emsp;晚安。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> Markdown </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++标准模板库(STL)</title>
      <link href="/2019/11/16/vector/"/>
      <url>/2019/11/16/vector/</url>
      
        <content type="html"><![CDATA[<h2 id="C-标准模板块-STL-介绍"><a href="#C-标准模板块-STL-介绍" class="headerlink" title="C++标准模板块(STL)介绍"></a>C++标准模板块(STL)介绍</h2><h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><h3 id="1-vector-的定义"><a href="#1-vector-的定义" class="headerlink" title="1. vector 的定义"></a>1. vector 的定义</h3><h4 id="emsp-emsp-单独定义一个vector"><a href="#emsp-emsp-单独定义一个vector" class="headerlink" title="&emsp;&emsp;单独定义一个vector"></a>&emsp;&emsp;单独定义一个vector</h4><pre><code>vector&lt;int&gt; name;vector&lt;double&gt; name;vector&lt;char&gt; name;vector&lt;node&gt; name;    // node是结构体类型vector&lt;vector&lt;typename&gt; &gt; name;    // &gt;&gt; 之间要有空格</code></pre><h4 id="emsp-emsp-定义vector数组的方法"><a href="#emsp-emsp-定义vector数组的方法" class="headerlink" title="&emsp;&emsp;定义vector数组的方法"></a>&emsp;&emsp;定义vector数组的方法</h4><pre><code>vector&lt;int&gt; vi[100];</code></pre><p>&emsp;&emsp;这样vi[0] - vi[99] 中每一个都是一个vector容器。</p><h3 id="2-vector-容器内元素的访问"><a href="#2-vector-容器内元素的访问" class="headerlink" title="2. vector 容器内元素的访问"></a>2. vector 容器内元素的访问</h3><p>&emsp;&emsp;vector 一般有两种访问方式：通过下标访问或通过迭代器访问。</p><h4 id="通过下标访问"><a href="#通过下标访问" class="headerlink" title="通过下标访问"></a>通过下标访问</h4><p>&emsp;&emsp;和访问普通的数组是一样的，对一个定义为 vector<typename> vi 的vector容器来说，直接访问 vi[index] 即可（如vi[0],vi[1]）。当然，这里下标是从 0 到 vi.size() - 1，访问这个范围以外的元素可能会运行报错。</p><h4 id="通过迭代器访问"><a href="#通过迭代器访问" class="headerlink" title="通过迭代器访问"></a>通过迭代器访问</h4><p>&emsp;&emsp;迭代器(itreator)可以理解为一种类似指针的东西，其定义是：</p><pre><code>vector&lt;typename&gt;::iterator it;</code></pre><p>&emsp;&emsp;这样 it 就是一个 vector<typename>::iterator 类型的变量（虽然这个变量看起来很长），其中 typename 就是定义 vector 时填写的类型。下面是 typename 为 int 和 double的举例：</p><pre><code>vector&lt;int&gt;::iterator it;vector&lt;double&gt;::iterator it;</code></pre><p>&emsp;&emsp;这样就得到了迭代器 it，并且可以通过 *it 来访问 vector 里的元素。<br>例如，有这样定义的一个 vector 容器：</p><pre><code>vector&lt;int&gt; vi;for(int i = 0; i &lt;= 5; i++) {    vi.push_back(i);    // push_back(i)在vi的末尾添加元素i，即依次添加 1 2 3 4 5}</code></pre><p>&emsp;&emsp;可以通过类似下标和指针访问数组的方式来访问容器内的元素：</p><pre><code>#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main() {    vector&lt;int&gt; vi;    for(int i = 1; i &lt;= 5; i++) {        vi.push_back(i);    }    // vi.begin()为取 vi 的首元素地址，而 it 指向这个地址    vector&lt;int&gt;::iterator it = vi.begin();    for(int i = 0; i &lt; 5; i++) {        cout &lt;&lt; *(it + i) &lt;&lt; &quot; &quot;;        }    return 0;}</code></pre><p>&emsp;&emsp;输出结果</p><pre><code>1 2 3 4 5</code></pre><p>&emsp;&emsp;从这里可以看出 <strong>v[i] 和 *(vi.begin() + i) 是等价的</strong>。<br>既然上面说到了begin()函数的作用为取 vi 的首地址元素，那么这里还要提到 end()函数。和begin()函数不同的是，end() 并不是取 vi 的尾元素地址，而是取尾元素地址的下一个地址。end()作为迭代器末尾标志，不存储任何元素。美国人思维比较<strong>左闭右开</strong>，在这里begin() 和 end()也是如此。</p><p>&emsp;&emsp;除此之外，迭代器还实现了两种自加操作：++it 和 it++（自减操作同理），于是有了另一中遍历 vector 中元素的写法：</p><pre><code>#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main() {    vector&lt;int&gt; vi;    for(int i = 1; i &lt;= 5; i++) {        vi.push_back(i);    }    // vector 的迭代器不支持 it &lt; vi.end() 写法，因此循环条件只能用 it != vi.end()    for(vector&lt;int&gt;::iterator it = vi.begin(); it != vi.end(); it++) {        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;        }    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>1 2 3 4 5</code></pre><p>&emsp;&emsp;最后需要指出，在常用的 <strong>STL</strong> 容器中，只有在 <strong>vector</strong> 和 <strong>string</strong> 中，才允许使用 <strong>vi.begin() + 3 这种迭代器加上整数的写法</strong>。</p><h3 id="3-vector-常用函数实例解析"><a href="#3-vector-常用函数实例解析" class="headerlink" title="3. vector 常用函数实例解析"></a>3. vector 常用函数实例解析</h3><h4 id="1-push-back"><a href="#1-push-back" class="headerlink" title="(1) push_back()"></a>(1) push_back()</h4><p>&emsp;&emsp;顾名思义，push_back(x)就是在 vector 后面添加一个元素 x，时间复杂度为O(1)。</p><p>&emsp;&emsp;示例如下：</p><pre><code>#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main() {    vector&lt;int&gt; vi;    for(int i = 1; i &lt;= 3; i++) {        vi.push_back(i);    // 将 1 2 3 依次插入 vi 末尾    }    for(int i =0; i &lt; vi.size(); i++) {    // size() 函数会给出 vi 中元素的个数        cout &lt;&lt; vi[i] &lt;&lt; &quot; &quot;;        }    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>1 2 3</code></pre><h4 id="2-pop-back"><a href="#2-pop-back" class="headerlink" title="(2) pop_back()"></a>(2) pop_back()</h4><p>&emsp;&emsp;有添加就会有删除，pop_back()用以删除 vector 的尾元素，时间复杂度为 O(1)。</p><p>&emsp;&emsp;示例如下：</p><pre><code>#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main() {    vector&lt;int&gt; vi;    for(int i = 1; i &lt;= 3; i++) {        vi.push_back(i);    // 将 1 2 3 依次插入 vi 末尾    }    vi.pop_back();    // 删除 vi 的尾元素    for(vector&lt;int&gt;::iterator it = vi.begin(); it != vi.end(); it++) {    // size() 函数会给出 vi 中元素的个数        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;        }    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>1 2</code></pre><h4 id="3-size"><a href="#3-size" class="headerlink" title="(3) size()"></a>(3) size()</h4><p>&emsp;&emsp;size()用来获得 vector 中元素的个数，时间复杂度为O(1)。size()返回的是 unsigned 类型，不过一半来说用 %d 不会出现太大问题，这一点对所有 <strong>STL</strong> 容器都是一样的。</p><p>&emsp;&emsp;示例如下：</p><pre><code>#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main() {    vector&lt;int&gt; vi;    for(int i = 1; i &lt;= 3; i++) {        vi.push_back(i);    // 将 1 2 3 依次插入 vi 末尾    }    cout &lt;&lt; vi.size();    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>3</code></pre><h4 id="4-clear"><a href="#4-clear" class="headerlink" title="(4) clear()"></a>(4) clear()</h4><p>&emsp;&emsp;clear() 用来清空 vector 中的所有元素，时间复杂度为 O(N)，其中 N 为 vector 中元素的个数。</p><p>&emsp;&emsp;示例如下：</p><pre><code>#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main() {    vector&lt;int&gt; vi;    for(int i = 1; i &lt;= 3; i++) {        vi.push_back(i);    // 将 1 2 3 依次插入 vi 末尾    }    vi.clear();    cout &lt;&lt; vi.size();    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>0</code></pre><h4 id="5-insert"><a href="#5-insert" class="headerlink" title="(5) insert()"></a>(5) insert()</h4><p>&emsp;&emsp;insert(it, x) 用来向 vector 的任意迭代器 it 处插入一个元素 x，时间复杂度为 O(N)。</p><p>&emsp;&emsp;示例如下：</p><pre><code>#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main() {    vector&lt;int&gt; vi;    for(int i = 1; i &lt;= 5; i++) {        vi.push_back(i);    // 此时为 1 2 3 4 5    }    vi.insert(vi.begin() + 2, -1); // 将 -1 插入 vi[2] 的位置    for(vector&lt;int&gt;::iterator it; it != vi.end(); it++) {        cout &lt;&lt; it &lt;&lt; &quot; &quot;;    }    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>1 2 -1 3 4 5</code></pre><h4 id="6-erase"><a href="#6-erase" class="headerlink" title="(6) erase()"></a>(6) erase()</h4><p>&emsp;&emsp;erase() 有两种方法：删除单个元素，删除一个区间内的所有元素。时间复杂符均为 O(n)。</p><p>&emsp;&emsp;① 删除单个元素。</p><p>&emsp;&emsp;erase(it) 即删除迭代器 it 处的元素。</p><p>&emsp;&emsp;示例如下：</p><pre><code>#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main() {    vector&lt;int&gt; vi;    for(int i = 5; i &lt;= 9; i++) {        vi.push_back(i);    // 插入 5 6 7 8 9    }    // 删除 8    vi.erase(vi.begin() + 3);    for(int i = 0; i &lt; vi.size(); i++) {        cout &lt;&lt; vi[i] &lt;&lt; &quot; &quot;;    }    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>5 6 7 9</code></pre><p>&emsp;&emsp;② 删除一个区间内的所有元素。</p><p>&emsp;&emsp;erase(first, last) 即删除[first, end)内所有的元素。</p><p>&emsp;&emsp;示例如下：</p><pre><code>#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main() {    vector&lt;int&gt; vi;    for(int i = 5; i &lt;= 9; i++) {        vi.push_back(i);    // 插入 5 6 7 8 9    }    vi.erase(vi.begin() + 1, vi.begin() + 4);    // 删除vi[1],vi[2],vi[3]    for(int i = 0; i &lt; vi.size(); i++) {        cout &lt;&lt; vi[i] &lt;&lt; &quot; &quot;;    }    return 0;}</code></pre><p>&emsp;&emsp;输出结果：</p><pre><code>5 9</code></pre><h3 id="vector-的常见用途"><a href="#vector-的常见用途" class="headerlink" title="vector 的常见用途"></a>vector 的常见用途</h3><h4 id="emsp-emsp-1-存储数据"><a href="#emsp-emsp-1-存储数据" class="headerlink" title="&emsp;&emsp;(1) 存储数据"></a>&emsp;&emsp;<strong>(1) 存储数据</strong></h4><p>&emsp;&emsp;① vector 本身可以作为数组使用，而且在一些元素个数不确定的场合可以很好地节省空间。</p><p>&emsp;&emsp;② 有些场合需要根据一些条件把部分数据输出在同一行，数据中间用空格隔开。由于输出数据的个数是不确定的，为了更方便地处理最后一个满足条件的数据后面，不输出额外的空格，可以先用 vector 记录所有需要输出的数据，然后一次性输出。</p><h4 id="emsp-emsp-2-用邻接表存储图"><a href="#emsp-emsp-2-用邻接表存储图" class="headerlink" title="&emsp;&emsp;(2) 用邻接表存储图"></a>&emsp;&emsp;<strong>(2) 用邻接表存储图</strong></h4><p>&emsp;&emsp;晚安。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> Markdown </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基础——对C的增强</title>
      <link href="/2019/11/15/c-ji-chu/"/>
      <url>/2019/11/15/c-ji-chu/</url>
      
        <content type="html"><![CDATA[<h2 id="C-基础—对C的增强"><a href="#C-基础—对C的增强" class="headerlink" title="C++基础—对C的增强"></a>C++基础—对C的增强</h2><p>我们都知道C++是完全兼容c的，而且对C做了一定的优化。</p><p>C++与C的不同在于：</p><h2 id="1-实用性的增强：变量可以任意定义了。"><a href="#1-实用性的增强：变量可以任意定义了。" class="headerlink" title="1.实用性的增强：变量可以任意定义了。"></a>1.实用性的增强：变量可以任意定义了。</h2><h3 id="在C中：变量的定义必须在函数使用之前，不然在早期的编译器中可能出错。"><a href="#在C中：变量的定义必须在函数使用之前，不然在早期的编译器中可能出错。" class="headerlink" title="在C中：变量的定义必须在函数使用之前，不然在早期的编译器中可能出错。"></a>在C中：变量的定义必须在函数使用之前，不然在早期的编译器中可能出错。</h3><pre><code>int i = 0;for(i = 0; i &lt; 10; i++) {    printf(&quot;Hello C&quot;);}</code></pre><h3 id="在C-中：变量可以任意定义，不过要注意变量的作用域和生存周期。"><a href="#在C-中：变量可以任意定义，不过要注意变量的作用域和生存周期。" class="headerlink" title="在C++中：变量可以任意定义，不过要注意变量的作用域和生存周期。"></a>在C++中：变量可以任意定义，不过要注意变量的作用域和生存周期。</h3><pre><code>for(int i = 0; i &lt; 10; i++) {    // 这里的i会随for循环的结束而被释放    cout &lt;&lt; &quot;Hello CPP&quot;;}</code></pre><h2 id="2-对全局检测能力的增强：不允许有重定义的现象出现。"><a href="#2-对全局检测能力的增强：不允许有重定义的现象出现。" class="headerlink" title="2.对全局检测能力的增强：不允许有重定义的现象出现。"></a>2.对全局检测能力的增强：不允许有重定义的现象出现。</h2><h3 id="在C-中：一个变量不管是声明还是定义只能出现一次。"><a href="#在C-中：一个变量不管是声明还是定义只能出现一次。" class="headerlink" title="在C++中：一个变量不管是声明还是定义只能出现一次。"></a>在C++中：一个变量不管是声明还是定义只能出现一次。</h3><pre><code>// int g_val;// int g_val = 10;// 这样定义在C中不回报错，但是在C++中会报错</code></pre><h2 id="3-对struct的增强。"><a href="#3-对struct的增强。" class="headerlink" title="3.对struct的增强。"></a>3.对struct的增强。</h2><pre><code>struct teacher {    int id;    char name[64];};void test() {    //在C语言中只能struct teacher t;这样定义除非加上typedef    //而在C++可以这样：    teacher t;}</code></pre><h2 id="4-对函数检测增强。"><a href="#4-对函数检测增强。" class="headerlink" title="4.对函数检测增强。"></a>4.对函数检测增强。</h2><h3 id="在C-中：对形参传递，返回值做了严格的检查，不允许任意传，任意调用，必须有返回值。"><a href="#在C-中：对形参传递，返回值做了严格的检查，不允许任意传，任意调用，必须有返回值。" class="headerlink" title="在C++中：对形参传递，返回值做了严格的检查，不允许任意传，任意调用，必须有返回值。"></a>在C++中：对形参传递，返回值做了严格的检查，不允许任意传，任意调用，必须有返回值。</h3><h3 id="在C中：可以任意，不过一般按照规范去写。"><a href="#在C中：可以任意，不过一般按照规范去写。" class="headerlink" title="在C中：可以任意，不过一般按照规范去写。"></a>在C中：可以任意，不过一般按照规范去写。</h3><pre><code>void f(int i) {    cout &lt;&lt; i &lt;&lt; endl; }void test3() {    f(1);    //在C中这样不会报错（warning），而在C++中这样会报错(error)。    //f(1, 2, 3);}</code></pre><h2 id="5-新增bool类型。"><a href="#5-新增bool类型。" class="headerlink" title="5.新增bool类型。"></a>5.新增bool类型。</h2><h3 id="在C语言中：非0代表真，0代表假。"><a href="#在C语言中：非0代表真，0代表假。" class="headerlink" title="在C语言中：非0代表真，0代表假。"></a>在C语言中：非0代表真，0代表假。</h3><pre><code>void test() {    int flag =1;//真    int flag=-1;//真    int flag=0;//假}</code></pre><h3 id="在C-中：新增了一个bool变量，bool变量的值只有0或1。"><a href="#在C-中：新增了一个bool变量，bool变量的值只有0或1。" class="headerlink" title="在C++中：新增了一个bool变量，bool变量的值只有0或1。"></a>在C++中：新增了一个bool变量，bool变量的值只有0或1。</h3><pre><code>void test() {    bool flag = true;    flag = false;//true--真，false--假    cout &lt;&lt; &quot;bool的size=&quot;&lt;&lt;sizeof(flag) &lt;&lt; endl;//1个字节    cout &lt;&lt; &quot;flag=&quot; &lt;&lt; flag &lt;&lt; endl;//为true值为1，为false值为0，不管为bool类型赋非0值则为1（true）,bool值只有0/1}</code></pre><h2 id="6-对三目运算符的增强。"><a href="#6-对三目运算符的增强。" class="headerlink" title="6.对三目运算符的增强。"></a>6.对三目运算符的增强。</h2><h3 id="在C中：a-gt-b-a-b-30一般会编译出错。原因是a-gt-b-a-b返回的是10，10-30会出错。"><a href="#在C中：a-gt-b-a-b-30一般会编译出错。原因是a-gt-b-a-b返回的是10，10-30会出错。" class="headerlink" title="在C中：a &gt; b ? a : b = 30一般会编译出错。原因是a &gt; b ? a : b返回的是10，10 = 30会出错。"></a>在C中：a &gt; b ? a : b = 30一般会编译出错。原因是a &gt; b ? a : b返回的是10，10 = 30会出错。</h3><h3 id="而在C-中：a-gt-b-a-b返回的是对b的引用。"><a href="#而在C-中：a-gt-b-a-b返回的是对b的引用。" class="headerlink" title="而在C++中：a &gt; b ? a : b返回的是对b的引用。"></a>而在C++中：a &gt; b ? a : b返回的是对b的引用。</h3><blockquote><p>注意：a &gt; b ? a : b作为左值时返回的结果不能有常量（常量不能取地址），做右值时任意。</p></blockquote><pre><code>void test(){    int a = 10;    int b = 20;    int max = 0;    max = a &gt; b ? a : b;    printf(&quot;%d\n&quot;,max);    //c：    //(a &gt; b ? a : b) = 30;    这样是错误的    *(a &gt; b ? &amp;a : &amp;b) = 30;    // 可以通过指针改变地址。    //c++:    (a &gt; b ? a : b) = 30;//在c中这个会出错20=30没有意义，在c++中可以使用a &gt; b ? a : b 返回b变量的引用        相当于：*(a&gt;b?&amp;a:&amp;b)=30    cout &lt;&lt; &quot;b=&quot; &lt;&lt; b &lt;&lt; endl;//30    //a &gt; b ? 10 : b = 30;//error,作为左值时返回的结果不能有常量（常量不能取地址），做右值时任意。}</code></pre><h2 id="7-const增强。"><a href="#7-const增强。" class="headerlink" title="7.const增强。"></a>7.const增强。</h2><h3 id="在C中："><a href="#在C中：" class="headerlink" title="在C中："></a>在C中：</h3><ol><li><p>const并不是一个常量，是一个变量加了只读属性。</p></li><li><p>const int 和 int const 是一样的。</p></li><li><p>const修饰的变量实际上是可以通过指针改变的，是一个假的常量。</p><pre><code> void test() {     const int a = 10;     int* p = &amp;a;     *p = 70;     printf(&quot;%d\n&quot;,a);    // 70 }</code></pre></li><li><p>与#define是有区别的。#define在预编译时处理，const在编译时处理。</p></li></ol><h3 id="const-int-c-int-const-c-和-const-int-count-的区别："><a href="#const-int-c-int-const-c-和-const-int-count-的区别：" class="headerlink" title="const int* c , int* const c 和 const int* count 的区别："></a>const int* c , int* const c 和 const int* count 的区别：</h3><ul><li>前者修饰const int表示指针C指向的地址的值不能改变，但是可以指向不同的地址。</li><li>中间修饰int 表示指针C不可以改变，但是指向的地址可以改变。</li><li>后者表示指针C不可以改变，指针指向的地址也不可以改变。</li></ul><h3 id="在c-中："><a href="#在c-中：" class="headerlink" title="在c++中："></a>在c++中：</h3><ol><li><p>const修饰表示的就是常量。const int a=1;这在C++中并不会在栈空间中开辟空间，而在内存中会有一个符号表去记录key—value。</p></li><li><p>a实际上是一个符号，是不能去访问地址的，但C++发现对一个const常量符号取地址时，会临时在栈上开辟一个临时空间，这个变量是匿名的，p–&gt;临时变量。</p></li></ol><h2 id="8-enum的增强。"><a href="#8-enum的增强。" class="headerlink" title="8.enum的增强。"></a>8.enum的增强。</h2><h3 id="C语言中枚举本质就是整型，枚举变量可以用任意整型赋值，而C-中枚举变量，只能用被枚举出来的元素初始化。"><a href="#C语言中枚举本质就是整型，枚举变量可以用任意整型赋值，而C-中枚举变量，只能用被枚举出来的元素初始化。" class="headerlink" title="C语言中枚举本质就是整型，枚举变量可以用任意整型赋值，而C++中枚举变量，只能用被枚举出来的元素初始化。"></a>C语言中枚举本质就是整型，枚举变量可以用任意整型赋值，而C++中枚举变量，只能用被枚举出来的元素初始化。</h3><pre><code>enum num {    a = 0,    b,    c,    d};void test() {    enum num n = a;    /*n = 0;    n = 1;    n = 2;    n = 3;*/    //在C语言中给枚举类型赋值时，可以通过枚举值赋值，而在C++中不可以}</code></pre><h2 id="9-引用的基本概念。"><a href="#9-引用的基本概念。" class="headerlink" title="9.引用的基本概念。"></a>9.引用的基本概念。</h2><ol><li>引用没有定义，是一种关系型声明。声明它和原有某一变量（实体）的关系。故而类型与原类型保持一致，且不分配内存。与被引用的变量有相同的内存地址。</li><li>声明的时候必须初始化，一经声明，不可变更。 </li><li>可对引用，再次引用。多次引用的结果，是某一变量具有多个别名。</li><li>&amp; 符号前有数据类型时，是引用，例如：int&amp;，double&amp;。其它皆为取地址。</li></ol><pre><code>#include&lt;iostream&gt;using namespace std;void change_value(int&amp; r) {    r = 30;}int main() {    int a = 20;    int b = 30;    int *p = &amp;a;    *p = 30;    cout &lt;&lt; a &lt;&lt; endl;    // 30    p = &amp;b;    *p = 20;    cout &lt;&lt; b &lt;&lt; endl;    // 20    int&amp; re = a;    // int&amp; 使用引用数据类型，re就是a的别名。     re = 50;    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;    // 50    // int&amp; re;    引用必须初始化。    int&amp; re2 = re;    // 可对引用，再次引用。    re2 = 60;    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;    cout &lt;&lt; &quot;-----------------&quot;&lt;&lt; endl;    change_value(a);    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;    return 0;}</code></pre><ol start="5"><li>通过引用 可以降低需要改变地址值时的难度。</li><li>引用作为函数的参数。</li></ol><pre><code>#include&lt;iostream&gt;using namespace std;struct student{    int id;    char name[64];};// 使用指针的方法 交换两个数的值 void swap(int* a, int* b) {    int temp;    temp = *a;    *a = *b;    *b = temp;}// 使用引用的方法 交换两个数的值 void swap2(int&amp; a, int&amp; b) {    int temp;    temp = a;    a = b;    b = temp;}// 使用普通的方法 void prints(student s) {    // 相当于 student s = s1; 变成了拷贝操作，不建议这样。     cout &lt;&lt; s.id &lt;&lt; &quot;\t&quot;&lt;&lt; s.name &lt;&lt; endl;}// 使用指针的方法 void prints2(student* s) {    // 相当于 student* s = &amp;s1;      cout &lt;&lt; s-&gt;id &lt;&lt; &quot;\t&quot;&lt;&lt; s-&gt;name &lt;&lt; endl;}// 使用引用的方法 void prints3(student&amp; s) {    // 相当于 student* s = &amp;s1;      cout &lt;&lt; s.id &lt;&lt; &quot;\t&quot;&lt;&lt; s.name &lt;&lt; endl;}int main() {    int a = 10, b = 20;//    swap(&amp;a, &amp;b);    swap2(a, b);    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;    cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;    student s1 = {10, &quot;zhangsan&quot;};    prints(s1);    prints2(s1);    prints3(s1);    return 0;} </code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>实用性增强（变量定义），全局变量定义检查（严格），变量类型检查严格，所有变量和函数定义必须有类型。</li><li>struct关键字（c中不是新类型），与class功能相同。</li><li>类型加强 bool 1个字节，但是只有 true 和 false。</li><li>C++中三目运算符，返回变量自身，C返回的是变量的值。</li><li>const增强<ul><li>指针变量和它所指向的内存空间变量是两个不同的概念。</li><li>C中冒牌货（只读变量有自己的存储空间）。</li><li>C++ const是一个只读常量，符号表机制，不可分配内存。</li><li>const是由编译器处理的，提供类型检查和作用域检查。</li><li>#define宏定义有预处理器处理，单纯的文本替换。</li></ul></li><li>引用<ul><li>引用没有定义，是一种关系型声明。声明它和原有某一变量（实体）的关系。故而类型与原类型保持一致，且不分配内存。与被引用的变量有相同的内存地址。</li><li>声明的时候必须初始化，一经声明，不可变更。 </li><li>可对引用，再次引用。多次引用的结果，是某一变量具有多个别名。</li><li>&amp; 符号前有数据类型时，是引用，例如：int&amp;，double&amp;。其它皆为取地址。</li><li>通过引用 可以降低需要改变地址值时的难度（好用）。</li><li>引用作为函数的参数。</li></ul></li></ol><p>&emsp;&emsp;晚安。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> Markdown </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客</title>
      <link href="/2019/11/13/wo-de-di-yi-pian-blog/"/>
      <url>/2019/11/13/wo-de-di-yi-pian-blog/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;<strong>忙碌了将近一天，终于把这个博客网站搭上了，哈哈哈，奈何自己太菜，只能用Hexo来写啦，搭这个博客的初衷很简单，就是想记录一下自己的经历吧。因为第一次搭博客，所以也遇见了一点小问题（具体的也忘记了。。。），不过什么也是自己琢磨出来的，总不能因为这点小小的问题就放弃把，失败就失败，大不了重来呗，我们还年轻，有的是机会重来。</strong></p><h3 id="我为什么要写博客？"><a href="#我为什么要写博客？" class="headerlink" title="我为什么要写博客？"></a><em>我为什么要写博客</em>？</h3><p>&emsp;&emsp;不管做什么事，总得知道做这件事的原因，做这件事的目的吧。</p><p>&emsp;&emsp;写博客对于我来说有什么或者将会带来什么好处，针对我个人而言，我认为写博客的最重要作用就是记录自己的成长足迹，因为它可以记录我各个阶段做了什么，收获了什么，不管是写技术博客，还是记录生活经历的博客，对我或多或少都是会有点感触的。</p><p>&emsp;&emsp;每个人都是从不懂到懂的，我写博客，其中的一个原因就是为了之后回顾自己之前做过的事情。看看之前的自己和现在的自己发生了什么变化，不管是学习方面还是生活方面都是一样的。我们都是一样的，没写文章的时候感觉自己很厉害，啥都懂，但是写的时候却写不出来，这其实就是对这个知识理解得不够透彻，从而可以认识自己的不足，进而才会改变自己。</p><p>&emsp;&emsp;我希望可以认识更多志同道合的朋友，互相讨论，互相弥补缺点，所以我也添加了”留言区”这个功能。希望将来来到我的博客的朋友们，都来发表发表自己的看法吧，说一说对于我写的某些东西的不足以及微乎其微的亮点吧。</p><p>&emsp;&emsp;多的不说了，以后我都会把他们记录在我的博客里面。</p><p>&emsp;&emsp;晚安</p><!--title         Markdown 的文件标题              文章标题，强烈建议填写此选项date          文件创建时的日期时间             发布时间，强烈建议填写此选项，且最好保证全局唯一author        根 _config.yml 中的 author      文章作者img            featureImages 中的某个值        文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: http://xxx.com/xxx.jpgtop            true                            推荐文章（文章是否置顶），如果 top 值为 true，则会作为首页推荐文章cover          false                            表示该文章是否需要加入到首页轮播封面中coverImg       无                            表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片password        无                               文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 password 的值，该值必须是用 SHA256 加密后的密码，防止被他人识破。前提是在主题的 config.yml 中激活了 verifyPassword 选项toc            true                             是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 config.yml 中激活了 toc 选项mathjax        false                             是否开启数学公式支持 ，本文章是否开启 mathjax，且需要在主题的 _config.yml 文件中也需要开启才行summary          无                             文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要categories       无                             文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类tags            无                              文章标签，一篇文章可以多个标签 -->]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> Markdown </tag>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
